---
phase: 02-listener-registry-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/listenerRegistry.ts
  - src/services/authFirebase.ts
  - src/composable/useAuthUseCases.ts
  - src/stores/authStore.ts
autonomous: true
must_haves:
  truths:
    - "Auth state is resolved via Promise before any data listeners start"
    - "Developer can inspect active listeners via ListenerRegistry.getDebugInfo()"
    - "Auth listener is registered with ListenerRegistry instead of stored in authStore"
  artifacts:
    - path: "src/services/listenerRegistry.ts"
      provides: "Centralized listener lifecycle management singleton"
      exports: ["listenerRegistry", "ListenerId", "ListenerMetadata"]
    - path: "src/services/authFirebase.ts"
      provides: "authStateReady() Promise-based auth coordination"
      exports: ["authStateReady"]
    - path: "src/composable/useAuthUseCases.ts"
      provides: "Refactored initializeAuth with Promise-based coordination"
    - path: "src/stores/authStore.ts"
      provides: "Cleaned store without authUnsubscribe field"
  key_links:
    - from: "src/composable/useAuthUseCases.ts"
      to: "src/services/listenerRegistry.ts"
      via: "import listenerRegistry, register auth listener"
      pattern: "listenerRegistry\\.register\\('auth'"
    - from: "src/composable/useAuthUseCases.ts"
      to: "src/services/authFirebase.ts"
      via: "await authStateReady() before setting isAuthReady"
      pattern: "await authStateReady\\(\\)"
---

<objective>
Create ListenerRegistry singleton and refactor auth initialization to use Promise-based coordination instead of timing buffers.

Purpose: Establishes the centralized listener tracking foundation and eliminates race conditions where data listeners start before auth completes.
Output: ListenerRegistry service, authStateReady() function, refactored initializeAuth, cleaned authStore.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-listener-registry-system/02-RESEARCH.md
@src/services/authFirebase.ts
@src/composable/useAuthUseCases.ts
@src/stores/authStore.ts
@src/errors/ListenerError.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ListenerRegistry singleton service</name>
  <files>src/services/listenerRegistry.ts</files>
  <action>
Create a new file `src/services/listenerRegistry.ts` implementing the centralized listener registry.

Define `ListenerId` as a union type covering all listener categories in the app:
`'auth' | 'teams' | 'surveys' | 'notifications' | 'messages' | 'cashbox-fines' | 'cashbox-payments' | 'cashbox-rules' | 'cashbox-history'`

Define `ListenerMetadata` interface with fields: `id: ListenerId`, `unsubscribe: () => void`, `createdAt: number`, `context: Record<string, unknown>`.

Implement class `ListenerRegistry` with private `listeners: Map<ListenerId, ListenerMetadata>` and these methods:
- `register(id, unsubscribe, context?)`: If listener with same ID exists, auto-cleanup old one first (call unsubscribe, delete from map), then add new entry. Log warn on auto-cleanup.
- `unregister(id)`: Call unsubscribe, delete from map, return boolean success. Wrap unsubscribe in try/catch to prevent errors from breaking cleanup chain.
- `unregisterAll()`: Iterate all entries and unregister each.
- `unregisterByScope(scope: 'team' | 'user')`: Unregister listeners by scope. Team-scoped: surveys, notifications, messages, cashbox-*. User-scoped: auth, teams.
- `isActive(id)`: Check if listener exists.
- `getActiveListeners()`: Return array of active ListenerIds.
- `getDebugInfo()`: Return array of `{ id, ageSeconds, context }` for each active listener.
- `getCount()`: Return number of active listeners.

Export a module-level singleton: `export const listenerRegistry = new ListenerRegistry()`.

Use the Firebase `Unsubscribe` type from `firebase/firestore` for the unsubscribe parameter type.
  </action>
  <verify>Run `quasar build` to confirm TypeScript compilation passes with no errors in the new file.</verify>
  <done>ListenerRegistry singleton exists at src/services/listenerRegistry.ts with register, unregister, unregisterAll, unregisterByScope, getDebugInfo methods. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add authStateReady and refactor auth initialization</name>
  <files>src/services/authFirebase.ts, src/composable/useAuthUseCases.ts, src/stores/authStore.ts</files>
  <action>
**In src/services/authFirebase.ts:**
Add a new `authStateReady` function that wraps `onAuthStateChanged` in a Promise. It should:
- Create a one-time listener via `onAuthStateChanged(auth, (user) => { unsubscribe(); resolve(user) })`
- Return `Promise<User | null>` resolving with the initial auth state
- Add it to the return object of `useAuthFirebase()`

**In src/composable/useAuthUseCases.ts:**
Refactor `initializeAuth` to be async and use two-step initialization:

Step 1 (initial state): `const initialUser = await authStateReady()`. If user exists, call `authStore.setUser(initialUser)`, get token result and set admin. Then set `authStore.setAuthReady(true)`. This eliminates the race condition where data listeners start before auth is confirmed.

Step 2 (continuous listener): Set up `authStateListener` for ongoing auth changes. In the callback:
- If user: update store, get admin claims, then call `setTeamListener(user.uid)` (same error handling as current)
- If no user: clear store, push to home route, call `listenerRegistry.unregisterAll()` to cleanup ALL listeners on logout (addresses LST-05)

Register the continuous auth listener with `listenerRegistry.register('auth', unsubscribe)`.

Remove the call to `authStore.setAuthUnsubscribe(unsubscribe)` - registry handles this now.

Import `listenerRegistry` from `@/services/listenerRegistry`.

**In src/stores/authStore.ts:**
Remove: `authUnsubscribe` ref, `setAuthUnsubscribe` function, and the unsubscribe logic from `cleanup()`. The cleanup function should still reset user, isLoading, isAdmin, isAuthReady, isTeamReady to defaults, but NOT manage listener unsubscription (registry handles that now). Remove `authUnsubscribe` and `setAuthUnsubscribe` from the return object.
  </action>
  <verify>Run `quasar build` to confirm compilation passes. Grep for `setTimeout` in useAuthUseCases.ts to confirm no timing buffers remain. Grep for `authUnsubscribe` across the codebase to confirm it's only removed, not still referenced elsewhere.</verify>
  <done>Auth initialization uses Promise-based coordination (await authStateReady before isAuthReady=true). Auth listener registered with ListenerRegistry. Logout calls listenerRegistry.unregisterAll(). authStore no longer stores unsubscribe function. Build passes with no errors.</done>
</task>

</tasks>

<verification>
- `quasar build` completes with no TypeScript errors
- `grep -r "authUnsubscribe" src/` returns zero matches (fully removed)
- `grep -r "setTimeout" src/composable/useAuthUseCases.ts` returns zero matches
- `listenerRegistry` is imported and used in useAuthUseCases.ts
</verification>

<success_criteria>
- ListenerRegistry singleton exists with register/unregister/unregisterAll/unregisterByScope/getDebugInfo
- initializeAuth is async, uses await authStateReady() before setting isAuthReady
- Auth listener registered via listenerRegistry.register('auth', ...)
- Logout path calls listenerRegistry.unregisterAll()
- authStore no longer manages authUnsubscribe
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-listener-registry-system/02-01-SUMMARY.md`
</output>
