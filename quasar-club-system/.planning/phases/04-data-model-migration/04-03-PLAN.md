---
phase: 04-data-model-migration
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/migrations/001-votes-to-subcollection.ts
  - src/migrations/verify-migration.ts
autonomous: true

must_haves:
  truths:
    - "Running the migration script copies all existing votes arrays into surveys/{surveyId}/votes/{userUid} subcollection documents"
    - "Running the verification script confirms zero mismatches between array votes and subcollection votes for every survey"
    - "Migration handles surveys with 0 votes, 1 vote, and 44+ votes without errors"
    - "Migration uses rate-limited batches to avoid Firestore RESOURCE_EXHAUSTED errors"
  artifacts:
    - path: "src/migrations/001-votes-to-subcollection.ts"
      provides: "Batch migration script copying votes arrays to subcollections"
      contains: "writeBatch"
    - path: "src/migrations/verify-migration.ts"
      provides: "Data integrity verification comparing array vs subcollection votes"
      contains: "validateVoteConsistency"
  key_links:
    - from: "src/migrations/001-votes-to-subcollection.ts"
      to: "firebase/firestore"
      via: "writeBatch for atomic batch writes per survey"
      pattern: "writeBatch"
    - from: "src/migrations/verify-migration.ts"
      to: "firebase/firestore"
      via: "getDocs to read both array and subcollection votes"
      pattern: "getDocs"
---

<objective>
Create migration script to copy existing votes from survey document arrays to subcollections, and a verification script to validate zero data loss.

Purpose: DAT-02 requires migration of live data with rollback capability. Plans 04-01 and 04-02 established the feature flags, security rules, and dual-write code paths, but existing production votes still live only in document arrays. This plan creates the one-time migration script to populate subcollections from those arrays, plus a verification script to confirm data integrity before toggling the USE_VOTE_SUBCOLLECTIONS flag.

Output: Two runnable TypeScript files in src/migrations/ that can be imported and executed from a browser console or a temporary admin page during a low-traffic window.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-model-migration/04-RESEARCH.md
@.planning/phases/04-data-model-migration/04-01-SUMMARY.md
@.planning/phases/04-data-model-migration/04-02-SUMMARY.md
@src/services/surveyFirebase.ts
@src/firebase/config.ts
@src/services/teamFirebase.ts (lines 47-84 for batch write pattern reference)
@src/interfaces/interfaces.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create votes-to-subcollection migration script</name>
  <files>src/migrations/001-votes-to-subcollection.ts</files>
  <action>
Create `src/migrations/` directory and `001-votes-to-subcollection.ts`.

This script uses the existing client-side Firebase SDK (import `db` from `@/firebase/config`), matching the project convention (no Firebase Admin SDK needed since the authenticated user running this will be a power user with write access via the security rules deployed in 04-01).

Implement `migrateAllSurveyVotes()` as the main exported async function:

1. **Fetch all surveys:** Use `getDocs(collection(db, 'surveys'))` to get every survey document.

2. **For each survey with votes:** Skip surveys where `votes` is empty or undefined (log skip).

3. **Batch write votes to subcollection:** For each survey, iterate its `votes` array and write each vote as a document at `surveys/{surveyId}/votes/{vote.userUid}` with fields `{ userUid: string, vote: boolean }`. Use `writeBatch` with Firestore's 500 operation limit per batch (follow the exact chunking pattern from `teamFirebase.ts` lines 57-62 — loop with `i += 499`, slice, commit).

4. **Rate limiting:** After every batch commit, add a 200ms delay (`await new Promise(resolve => setTimeout(resolve, 200))`) to avoid hitting Firestore write rate limits. After every 10 batches (approximately 5000 writes), add a 1-second pause.

5. **Error handling per survey:** Wrap each survey's migration in try/catch. On failure, log the surveyId and error, continue to next survey. Do NOT abort the entire migration on a single survey failure.

6. **Results tracking:** Track and return an object:
   ```typescript
   interface MigrationResult {
     totalSurveys: number
     surveysWithVotes: number
     surveysSkipped: number  // surveys with 0 votes
     successCount: number
     failedCount: number
     totalVotesMigrated: number
     errors: Array<{ surveyId: string; error: string }>
     durationMs: number
   }
   ```

7. **Logging:** Use `createLogger('migration')` from `src/utils/logger` for structured logging. Log: migration start, each survey migrated (surveyId + vote count), each failure, and final summary with all counts.

8. **Idempotency:** Use `batch.set()` (not `batch.create()`) so re-running the migration overwrites existing subcollection documents rather than failing on duplicate keys. This makes the script safe to re-run.

Export both `migrateAllSurveyVotes` and `MigrationResult` type for use by the verification script and temporary admin page.
  </action>
  <verify>
Run `npx quasar build` — zero TypeScript errors. Verify the file exists at `src/migrations/001-votes-to-subcollection.ts` and exports `migrateAllSurveyVotes`. Grep for `writeBatch` and `setTimeout` to confirm batch operations and rate limiting are present.
  </verify>
  <done>
Migration script exists, imports from existing Firebase config, uses writeBatch with 499-operation chunks, includes 200ms delays between batches and 1s pauses every 10 batches, handles errors per-survey without aborting, tracks results with counts and timing, and is idempotent via set() semantics. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create migration verification script</name>
  <files>src/migrations/verify-migration.ts</files>
  <action>
Create `src/migrations/verify-migration.ts`.

Implement `verifyMigrationIntegrity()` as the main exported async function:

1. **Fetch all surveys:** Same pattern as migration script — `getDocs(collection(db, 'surveys'))`.

2. **For each survey, compare array vs subcollection:**
   a. Read `votes` array from survey document data (handle undefined/null as empty array)
   b. Read subcollection votes via `getDocs(collection(db, 'surveys', surveyId, 'votes'))`
   c. **Count check:** Array length must equal subcollection size
   d. **Value check:** For each array vote, find matching subcollection vote by `userUid` and compare `vote` boolean value
   e. **Orphan check:** For each subcollection vote, confirm a matching array vote exists (catches extra subcollection docs)

3. **Mismatch tracking:** For each mismatch, record:
   ```typescript
   interface VoteMismatch {
     surveyId: string
     type: 'count_mismatch' | 'missing_in_subcollection' | 'missing_in_array' | 'value_mismatch'
     details: string  // e.g. "array: 12, subcollection: 11" or "userUid xyz missing"
   }
   ```

4. **Results:** Return:
   ```typescript
   interface VerificationResult {
     totalSurveys: number
     surveysChecked: number
     surveysWithVotes: number
     perfectMatches: number
     mismatchCount: number
     mismatches: VoteMismatch[]
     passed: boolean  // true only if mismatchCount === 0
     durationMs: number
   }
   ```

5. **Logging:** Use `createLogger('migration-verify')`. Log each survey checked (surveyId + array count + subcollection count), each mismatch with full details, and final PASSED/FAILED summary.

6. **Safety:** This script is read-only — it never writes to Firestore. It only uses `getDocs` and `getDoc`.

Export `verifyMigrationIntegrity`, `VerificationResult`, and `VoteMismatch` types.
  </action>
  <verify>
Run `npx quasar build` — zero TypeScript errors. Verify the file exists at `src/migrations/verify-migration.ts` and exports `verifyMigrationIntegrity`. Grep confirms no `updateDoc`, `setDoc`, `writeBatch`, or `deleteDoc` calls (read-only script).
  </verify>
  <done>
Verification script exists, compares array votes vs subcollection votes for every survey, checks counts + individual values + orphans in both directions, returns structured result with passed/failed boolean, is completely read-only, and build passes.
  </done>
</task>

</tasks>

<verification>
1. `npx quasar build` completes with zero errors
2. `src/migrations/001-votes-to-subcollection.ts` exists and exports `migrateAllSurveyVotes`
3. `src/migrations/verify-migration.ts` exists and exports `verifyMigrationIntegrity`
4. Migration script uses `writeBatch` with chunking (499 ops per batch)
5. Migration script has rate limiting (200ms between batches, 1s every 10 batches)
6. Migration script is idempotent (uses `set()` not `create()`)
7. Migration script continues on per-survey errors (does not abort)
8. Verification script is read-only (no write operations)
9. Verification script checks count equality, value equality, and orphans in both directions
10. Both scripts use `createLogger` for structured logging
</verification>

<success_criteria>
- Migration script can copy all existing votes from arrays to subcollections in batches
- Verification script can confirm zero data loss by comparing array and subcollection data
- Both scripts handle edge cases (empty votes, missing fields, surveys with no votes)
- Migration is idempotent and safe to re-run
- Rate limiting prevents Firestore quota errors
- Build passes cleanly with both new files
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-model-migration/04-03-SUMMARY.md`
</output>
