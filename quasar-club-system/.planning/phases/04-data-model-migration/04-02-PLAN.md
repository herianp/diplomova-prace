---
phase: 04-data-model-migration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/services/surveyFirebase.ts
  - src/composable/useSurveyUseCases.ts
autonomous: true

must_haves:
  truths:
    - "When DUAL_WRITE_VOTES is true, voting writes to both array and subcollection atomically via batch"
    - "When USE_VOTE_SUBCOLLECTIONS is true, vote reads come from subcollection instead of array"
    - "Vote submission works identically from user perspective regardless of feature flag state"
    - "Teams with 30+ members see all votes without IN query limit errors"
  artifacts:
    - path: "src/services/surveyFirebase.ts"
      provides: "addOrUpdateVote with feature-flag-gated dual-write and subcollection-only modes"
      contains: "addVoteToSubcollection"
    - path: "src/services/surveyFirebase.ts"
      provides: "getVotesFromSubcollection for reading votes from subcollection"
      contains: "getVotesFromSubcollection"
    - path: "src/composable/useSurveyUseCases.ts"
      provides: "voteOnSurvey that works with both array and subcollection backends"
  key_links:
    - from: "src/services/surveyFirebase.ts"
      to: "src/config/featureFlags.ts"
      via: "isFeatureEnabled checks in addOrUpdateVote and getVotesFromSubcollection"
      pattern: "isFeatureEnabled.*DUAL_WRITE|isFeatureEnabled.*USE_VOTE_SUBCOLLECTIONS"
    - from: "src/services/surveyFirebase.ts"
      to: "firebase/firestore writeBatch"
      via: "batch.set for dual-write atomicity"
      pattern: "writeBatch"
---

<objective>
Implement subcollection vote read/write logic gated by feature flags, with dual-write support for safe migration transition.

Purpose: This is the core DAT-01 implementation — subcollection storage backend for votes. Dual-write mode enables gradual migration (DAT-02 prerequisite). The subcollection pattern eliminates the 1MB document size limit for votes and avoids IN query issues (DAT-03) since votes are queried by parent survey, not by user ID list.

Output: Updated surveyFirebase.ts with three code paths (array-only, dual-write, subcollection-only) controlled by feature flags. Updated use case layer to support subcollection reads when enabled.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-model-migration/04-RESEARCH.md
@.planning/phases/04-data-model-migration/04-01-SUMMARY.md
@src/services/surveyFirebase.ts
@src/composable/useSurveyUseCases.ts
@src/config/featureFlags.ts
@src/interfaces/interfaces.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add subcollection write functions and dual-write logic to surveyFirebase</name>
  <files>src/services/surveyFirebase.ts</files>
  <action>
Add Firebase imports needed: `writeBatch`, `getDocs`, `collection` (some may already be imported — check first).

Add internal helper functions (not exported):

1. `addVoteToSubcollection(surveyId, userUid, vote)` — writes a single vote document to `surveys/{surveyId}/votes/{userUid}`. Use `setDoc` with merge to create or overwrite. Document contains `{ userUid, vote, updatedAt: new Date() }`.

2. `addVoteDualWrite(surveyId, userUid, newVote, votes)` — uses `writeBatch` for atomic dual-write:
   - Operation 1: Update survey document's votes array (same logic as current addOrUpdateVote)
   - Operation 2: Set vote document in subcollection `surveys/{surveyId}/votes/{userUid}`
   - Commit batch atomically

3. `getVotesFromSubcollection(surveyId)` — reads all documents from `surveys/{surveyId}/votes/` collection, returns `IVote[]`. Maps each doc to `{ userUid: doc.id, vote: doc.data().vote }`.

**Modify `addOrUpdateVote`** to use feature flags:
```typescript
import { isFeatureEnabled } from '@/config/featureFlags'

const addOrUpdateVote = async (surveyId: string, userUid: string, newVote: boolean, votes: IVote[]) => {
  try {
    // Check if vote unchanged (optimization - works for both backends)
    const existingVote = votes.find((vote) => vote.userUid === userUid)
    if (existingVote && existingVote.vote === newVote) return

    if (isFeatureEnabled('DUAL_WRITE_VOTES')) {
      await addVoteDualWrite(surveyId, userUid, newVote, votes)
    } else if (isFeatureEnabled('USE_VOTE_SUBCOLLECTIONS')) {
      await addVoteToSubcollection(surveyId, userUid, newVote)
    } else {
      // Current array-only logic (existing code)
      let updatedVotes: IVote[]
      if (existingVote) {
        updatedVotes = votes.map((vote) =>
          vote.userUid === userUid ? { ...vote, vote: newVote } : vote
        )
      } else {
        updatedVotes = [...votes, { userUid, vote: newVote }]
      }
      await updateDoc(surveyRef, { votes: updatedVotes })
    }
  } catch (error: unknown) {
    // existing error handling
  }
}
```

Export `getVotesFromSubcollection` in the return object — it will be needed by the use case layer for subcollection reads.

Also update `verifySurvey` and `updateSurveyVotes` to dual-write to subcollection when DUAL_WRITE_VOTES is enabled:
- `verifySurvey`: When updatedVotes provided and DUAL_WRITE_VOTES is true, also write each vote to subcollection in a batch
- `updateSurveyVotes`: When DUAL_WRITE_VOTES is true, also sync votes to subcollection
  </action>
  <verify>
Run `npx quasar build` — zero TypeScript errors. Grep for `writeBatch` in surveyFirebase.ts confirms batch import and usage. Grep for `isFeatureEnabled` confirms feature flag integration.
  </verify>
  <done>
addOrUpdateVote has three code paths gated by feature flags: array-only (default), dual-write (transition), subcollection-only (post-migration). getVotesFromSubcollection is exported. Dual-write uses writeBatch for atomicity. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update use case layer and survey listener for subcollection reads</name>
  <files>src/composable/useSurveyUseCases.ts, src/services/surveyFirebase.ts</files>
  <action>
**In `src/services/surveyFirebase.ts`:**

Update `getSurveysByTeamId` listener to optionally enrich surveys with subcollection votes when `USE_VOTE_SUBCOLLECTIONS` is true:
- After mapping snapshot docs to surveys, if `isFeatureEnabled('USE_VOTE_SUBCOLLECTIONS')`, for each survey call `getVotesFromSubcollection(survey.id)` and replace `survey.votes` with the result
- Use `Promise.all` to parallelize subcollection reads across surveys
- Wrap in try/catch — if subcollection read fails, fall back to array votes with a log.warn

This approach means the rest of the application (components, pages, charts) continues reading `survey.votes` as before — the data source is transparently swapped at the listener level.

**In `src/composable/useSurveyUseCases.ts`:**

Update `voteOnSurvey`:
- When `USE_VOTE_SUBCOLLECTIONS` is true, the `votes` parameter passed to `addOrUpdateVote` may be from subcollection already — no change needed since `addOrUpdateVote` handles the flag internally
- Add import for `isFeatureEnabled` from `@/config/featureFlags`
- No structural changes needed — the service layer handles the branching

**Note on DAT-03 (IN query limit):** The subcollection approach eliminates the IN query problem for votes entirely. Votes are stored per-survey in subcollections and queried by getDocs on the subcollection — no IN clause needed. The existing `firestoreUtils.ts` queryByIdsInChunks utility remains for team member queries (different concern). Add a code comment in surveyFirebase.ts noting this.
  </action>
  <verify>
Run `npx quasar build` — zero TypeScript errors. With both flags false (default), existing behavior is unchanged. Code review: survey listener enriches votes from subcollection only when USE_VOTE_SUBCOLLECTIONS is true.
  </verify>
  <done>
Survey listener transparently swaps vote data source based on feature flag. When USE_VOTE_SUBCOLLECTIONS=true, votes come from subcollection; when false, from array. All downstream consumers (components, charts, reports) see the same ISurvey.votes interface regardless of backend. DAT-03 IN query limit is addressed by subcollection architecture (no IN queries for votes).
  </done>
</task>

</tasks>

<verification>
1. `npx quasar build` completes with zero errors
2. Feature flag `USE_VOTE_SUBCOLLECTIONS=false` + `DUAL_WRITE_VOTES=false`: app behavior unchanged (array reads/writes)
3. Code review: `addOrUpdateVote` has three distinct code paths gated by feature flags
4. Code review: `getSurveysByTeamId` enriches votes from subcollection when flag is true
5. Code review: `writeBatch` used for atomic dual-write operations
6. `getVotesFromSubcollection` is exported from surveyFirebase
</verification>

<success_criteria>
- Subcollection write (addVoteToSubcollection) and read (getVotesFromSubcollection) functions implemented
- Dual-write uses writeBatch for atomicity between array and subcollection
- Survey listener transparently enriches votes from subcollection when flag enabled
- All existing behavior unchanged when both flags are false (default state)
- No IN query needed for vote reads (subcollection architecture eliminates DAT-03 for votes)
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-model-migration/04-02-SUMMARY.md`
</output>
