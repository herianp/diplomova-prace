---
phase: 01-error-system-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/authFirebase.ts
  - src/services/teamFirebase.ts
  - src/services/surveyFirebase.ts
  - src/services/cashboxFirebase.ts
  - src/services/messageFirebase.ts
  - src/services/notificationFirebase.ts
autonomous: true

must_haves:
  truths:
    - "Firebase service errors are typed (no `catch (error)` without type)"
    - "Auth errors map to AuthError with Firebase error codes"
    - "Firestore errors map to FirestoreError with operation type"
  artifacts:
    - path: "src/services/authFirebase.ts"
      provides: "Auth operations throwing typed AuthError"
      contains: "mapFirebaseAuthError"
    - path: "src/services/surveyFirebase.ts"
      provides: "Survey operations throwing typed FirestoreError"
      contains: "mapFirestoreError"
    - path: "src/services/teamFirebase.ts"
      provides: "Team operations throwing typed FirestoreError"
      contains: "mapFirestoreError"
  key_links:
    - from: "src/services/authFirebase.ts"
      to: "src/errors/errorMapper.ts"
      via: "import mapFirebaseAuthError"
      pattern: "import.*mapFirebaseAuthError"
    - from: "src/services/surveyFirebase.ts"
      to: "src/errors/errorMapper.ts"
      via: "import mapFirestoreError"
      pattern: "import.*mapFirestoreError"
---

<objective>
Migrate all 6 Firebase service files to use typed error classes instead of generic error throws.

Purpose: Replace console.error + throw pattern with typed error mapping for programmatic error handling
Output: All Firebase services throw typed errors (AuthError, FirestoreError, ListenerError)
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/.planning/PROJECT.md
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/.planning/ROADMAP.md
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/.planning/STATE.md
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/.planning/phases/01-error-system-foundation/01-RESEARCH.md
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/.planning/codebase/CONVENTIONS.md
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/.planning/codebase/ARCHITECTURE.md
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/src/services/authFirebase.ts
@C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system/src/services/surveyFirebase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate auth and team services to typed errors</name>
  <files>
    src/services/authFirebase.ts
    src/services/teamFirebase.ts
  </files>
  <action>
Update authFirebase.ts and teamFirebase.ts to use typed errors:

**authFirebase.ts changes:**
- Import { mapFirebaseAuthError } from '@/errors/errorMapper'
- Find all catch blocks (loginUser, logoutUser, registerUser, createUserInFirestore, getUserFromFirestore, updateUserProfile, changeUserPassword)
- Replace pattern:
  ```typescript
  catch (error) {
    console.error('Context: ${error.code} - ${error.message}')
    throw error
  }
  ```
  With:
  ```typescript
  catch (error: unknown) {
    const authError = mapFirebaseAuthError(error)
    console.error('Context:', authError.code, authError.message)
    throw authError
  }
  ```
- Keep descriptive console.error contexts (e.g., "Login Error:", "Registration Error:")
- Total functions to update: 7 catch blocks

**teamFirebase.ts changes:**
- Import { mapFirestoreError } from '@/errors/errorMapper'
- Import { ListenerError } from '@/errors'
- Find all catch blocks in CRUD operations
- Replace with mapFirestoreError, providing operation type:
  - createTeam, addUserToTeam, removeUserFromTeam → operation: 'write'
  - getTeamsByUserId, getTeamById → operation: 'read'
  - deleteTeam, updateTeam → operation: 'delete' or 'write'
- Example:
  ```typescript
  catch (error: unknown) {
    const firestoreError = mapFirestoreError(error, 'write')
    console.error('Error creating team:', firestoreError.message)
    throw firestoreError
  }
  ```
- For listener error callbacks (onSnapshot error handlers):
  - Wrap callback with try-catch
  - Catch and create ListenerError:
    ```typescript
    onSnapshot(query, callback, (error) => {
      const listenerError = new ListenerError('teams', 'errors.listener.failed', { originalError: error.message })
      console.error('Team listener error:', listenerError)
      callback([]) // Graceful degradation
    })
    ```

Follow conventions: Type unknown in catch, camelCase, no semicolons.
  </action>
  <verify>
    TypeScript compilation succeeds: `npm run build`
    No `catch (error)` without type in authFirebase.ts or teamFirebase.ts: `grep -n "catch (error)" src/services/authFirebase.ts src/services/teamFirebase.ts`
    Test auth error: Attempt login with wrong password, catch and verify `instanceof AuthError`
    Test Firestore error: Attempt to create team without permission, verify `instanceof FirestoreError`
  </verify>
  <done>
    All auth operations throw AuthError with Firebase codes
    All team operations throw FirestoreError with operation types
    Listener errors wrapped in ListenerError
    No untyped catch blocks remain
    Console.error calls retain descriptive context
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate survey, cashbox, message, notification services to typed errors</name>
  <files>
    src/services/surveyFirebase.ts
    src/services/cashboxFirebase.ts
    src/services/messageFirebase.ts
    src/services/notificationFirebase.ts
  </files>
  <action>
Update remaining Firebase services to use typed errors:

**surveyFirebase.ts changes:**
- Import { mapFirestoreError } from '@/errors/errorMapper'
- Import { ListenerError } from '@/errors'
- Update all catch blocks with mapFirestoreError:
  - getSurveysByTeamId listener → wrap error callback with ListenerError('surveys', ...)
  - addSurvey, updateSurvey, addVote, addSurveyVote → operation: 'write'
  - deleteSurvey → operation: 'delete'
  - Query operations → operation: 'read'
- Special handling for permission-denied in listeners (existing pattern at lines ~50-60):
  - Keep graceful degradation (callback with empty array)
  - But wrap in try-catch and create ListenerError for logging
  - Example:
    ```typescript
    onSnapshot(query, callback, (error) => {
      const listenerError = new ListenerError('surveys', 'errors.listener.failed', { code: error.code })
      console.warn('Survey listener error:', listenerError.message)
      callback([]) // Existing graceful degradation
    })
    ```

**cashboxFirebase.ts changes:**
- Import { mapFirestoreError } from '@/errors/errorMapper'
- Update all CRUD operations:
  - getFineRules, getFines, getPayments → operation: 'read'
  - addFine, addPayment, updateFineRule → operation: 'write'
  - deleteFine, deletePayment → operation: 'delete'

**messageFirebase.ts changes:**
- Import { mapFirestoreError } from '@/errors/errorMapper'
- Update operations:
  - getMessagesByTeamId → operation: 'read'
  - sendMessage → operation: 'write'

**notificationFirebase.ts changes:**
- Import { mapFirestoreError } from '@/errors/errorMapper'
- Import { ListenerError } from '@/errors'
- Update operations:
  - getNotificationsByUserId listener → wrap error callback with ListenerError('notifications', ...)
  - createSurveyNotification, markAsRead → operation: 'write'
  - Query operations → operation: 'read'

For ALL services:
- Replace `catch (error)` with `catch (error: unknown)`
- Map to FirestoreError using appropriate operation type
- Preserve existing console.error context messages
- Keep listener graceful degradation pattern (callback with empty data on permission-denied)

Follow conventions: Type unknown in catch, camelCase, no semicolons.
  </action>
  <verify>
    TypeScript compilation succeeds: `npm run build`
    No untyped catches remain: `grep -rn "catch (error[^:])" src/services/`
    Test survey listener: Load survey page, verify no console errors
    Test permission-denied: Simulate Firestore rules denial, verify ListenerError logged but app continues
    Check error instanceof: In use case catches, verify errors are FirestoreError or ListenerError instances
  </verify>
  <done>
    All survey operations throw FirestoreError
    All cashbox operations throw FirestoreError
    All message operations throw FirestoreError
    All notification operations throw FirestoreError
    Listener errors wrapped in ListenerError with graceful degradation
    No `catch (error)` without type annotation in any service file
    Console logging preserves descriptive context
  </done>
</task>

</tasks>

<verification>
Run full TypeScript build: `npm run build` (no errors)
Search for untyped catches: `grep -rn "catch (error[^:])" src/services/` (should return empty)
Test application flows:
  - Login with wrong password → AuthError thrown
  - Create survey → FirestoreError on failure
  - Load dashboard → ListenerError logged on permission issues but app continues
Check error types in browser:
  - Import a service function
  - Call it with invalid data
  - Catch error and verify `error instanceof FirestoreError` or `error instanceof AuthError`
</verification>

<success_criteria>
- All 6 Firebase services throw typed errors
- Auth errors are AuthError instances with Firebase error codes
- Firestore errors are FirestoreError instances with operation types (read/write/delete)
- Listener errors wrapped in ListenerError for debugging
- Graceful degradation on permission-denied errors (app continues with empty data)
- No `catch (error)` blocks without TypeScript type annotation
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-system-foundation/01-03-SUMMARY.md`
</output>
