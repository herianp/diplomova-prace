---
phase: 08-test-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vitest.config.ts
  - src/services/__tests__/listenerRegistry.test.ts
  - src/composable/__tests__/useFormValidation.test.ts
autonomous: true

must_haves:
  truths:
    - "yarn test:coverage runs and produces a coverage report"
    - "ListenerRegistry register/unregister/scope tests all pass"
    - "useFormValidation rules (required, email, minLength, futureDate, etc.) tests all pass"
    - "createFormValidator reactive validation tests pass"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Coverage configuration with v8 provider and 70% thresholds"
      contains: "coverage"
    - path: "src/services/__tests__/listenerRegistry.test.ts"
      provides: "ListenerRegistry unit tests"
      contains: "ListenerRegistry"
    - path: "src/composable/__tests__/useFormValidation.test.ts"
      provides: "Form validation rule tests"
      contains: "useFormValidation"
  key_links:
    - from: "vitest.config.ts"
      to: "package.json"
      via: "test:coverage script"
      pattern: "vitest run --coverage"
---

<objective>
Install @vitest/coverage-v8, configure coverage in vitest.config.ts, and write unit tests for the two pure-logic modules: ListenerRegistry (TST-07) and useFormValidation (TST-06).

Purpose: Establishes coverage infrastructure and tests the simplest modules first (no mocking needed), creating the foundation for subsequent test plans.
Output: Working coverage config, ~40+ passing tests for pure logic modules.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@vitest.config.ts
@package.json
@src/services/listenerRegistry.ts
@src/composable/useFormValidation.ts
@src/composable/__tests__/useDateHelpers.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install coverage dependency and configure vitest coverage</name>
  <files>package.json, vitest.config.ts</files>
  <action>
1. Install @vitest/coverage-v8 as a dev dependency:
   `yarn add -D @vitest/coverage-v8`

2. Add `test:coverage` script to package.json scripts:
   `"test:coverage": "vitest run --coverage"`

3. Update vitest.config.ts to add coverage configuration inside `test`:
   ```typescript
   coverage: {
     provider: 'v8',
     reporter: ['text', 'lcov', 'html'],
     include: [
       'src/composable/**/*.ts',
       'src/services/listenerRegistry.ts',
     ],
     exclude: [
       'src/**/__tests__/**',
       'src/boot/**',
       'src/i18n/**',
       'src/router/**',
       'src/pages/**',
       'src/layouts/**',
       'src/components/**',
       'src/firebase/config.ts',
       'src/migrations/**'
     ],
     thresholds: {
       lines: 70,
       functions: 70,
       branches: 70,
       statements: 70
     }
   }
   ```

4. Verify: Run `yarn vitest run --coverage` and confirm it produces a coverage report (even with low numbers initially — thresholds will be met after all tests are written).
  </action>
  <verify>Run `yarn vitest run` — existing tests (useDateHelpers, useSurveyFilters) still pass. Coverage config accepted without errors.</verify>
  <done>package.json has test:coverage script, vitest.config.ts has coverage block with v8 provider, include/exclude lists, and 70% thresholds.</done>
</task>

<task type="auto">
  <name>Task 2: Write ListenerRegistry and useFormValidation unit tests</name>
  <files>src/services/__tests__/listenerRegistry.test.ts, src/composable/__tests__/useFormValidation.test.ts</files>
  <action>
**ListenerRegistry tests** (src/services/__tests__/listenerRegistry.test.ts):

Import the `ListenerRegistry` CLASS (not the singleton) to avoid module-level `window.__listenerDebug` side effects. Mock `src/utils/logger` with no-op to prevent console clutter. Create fresh `new ListenerRegistry()` in `beforeEach`.

Test cases for TST-07:
- register: adds listener, getCount() returns 1, isActive returns true
- unregister: calls unsubscribe fn, getCount() returns 0, isActive returns false
- unregister non-existent: returns false, no error
- unregisterAll: calls all unsubscribe fns, getCount() returns 0
- auto-cleanup on re-register: old unsubscribe called before new one registered
- unregisterByScope('team'): unsubscribes surveys, notifications, messages, cashbox-* but NOT auth, teams
- unregisterByScope('user'): unsubscribes auth, teams but NOT team-scoped listeners
- getActiveListeners: returns array of registered IDs
- getDebugInfo: returns metadata with id, ageSeconds, context
- unsubscribe error handling: swallows error from unsubscribe fn, still removes listener
- getCount: returns correct count after register/unregister operations

**useFormValidation tests** (src/composable/__tests__/useFormValidation.test.ts):

Direct composable invocation, no mocks needed (pure logic). Use `vi.useFakeTimers()` for date-dependent rules (futureDate, pastDate).

Test cases for TST-06:
- required: returns error message for empty string, null, undefined; returns true for non-empty value
- requiredSelect: returns error for null/undefined/''; returns true for valid selection
- email: returns true for valid emails; returns error for invalid format; returns true for empty (optional)
- minLength: returns error when below min; returns true when at/above min; returns true for empty
- maxLength: returns error when above max; returns true when at/below max
- pattern: returns error when regex fails; returns true on match
- numeric: returns error for non-numeric; returns true for valid numbers
- positiveNumber: returns error for 0 and negative; returns true for positive
- url: returns error for invalid URL; returns true for valid URL
- dateFormat: returns error for bad format; returns true for YYYY-MM-DD
- timeFormat: returns error for bad format; returns true for HH:MM
- futureDate: (fake timers set to 2026-01-15) rejects past date, accepts future date, accepts today
- pastDate: (fake timers) rejects future date, accepts past date
- confirm: returns error when values don't match; returns true when matching
- custom: delegates to validator function
- validateField: returns null for valid field, returns first error for invalid
- validateFields: returns isValid=true when all valid, returns isValid=false with errors map when invalid
- createFormValidator: validate() populates errors ref, isValid computed updates, clearErrors() resets, validateField(name) validates single field and sets touched
- surveyRules.title: returns array with required + minLength + maxLength rules
- userRules.email: returns array with required + email rules
- userRules.confirmPassword: returns array with required + confirm rules
- getFieldError: returns error only when touched AND has error
- hasFieldError: returns boolean based on touched state
  </action>
  <verify>Run `yarn vitest run` — all new tests pass alongside existing tests. Run `yarn vitest run --coverage` — coverage report shows ListenerRegistry and useFormValidation with high coverage.</verify>
  <done>ListenerRegistry has tests covering register, unregister, scope cleanup, auto-cleanup, debug info, and error handling. useFormValidation has tests covering all 14 rule types, validateField, validateFields, createFormValidator reactive behavior, preset rule sets (surveyRules, userRules), and helper functions.</done>
</task>

</tasks>

<verification>
1. `yarn vitest run` passes all tests (existing + new)
2. `yarn vitest run --coverage` produces coverage report
3. ListenerRegistry tests cover: register, unregister, unregisterAll, unregisterByScope, auto-cleanup, getDebugInfo, error handling
4. useFormValidation tests cover: all 14 rules, validateField, validateFields, createFormValidator, date rules with fake timers
</verification>

<success_criteria>
- All tests pass with `yarn vitest run`
- Coverage report generated with `yarn vitest run --coverage`
- ListenerRegistry coverage > 90% (pure class, easy to cover)
- useFormValidation coverage > 90% (pure functions, easy to cover)
</success_criteria>

<output>
After completion, create `.planning/phases/08-test-implementation/08-01-SUMMARY.md`
</output>
