---
phase: 08-test-implementation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/composable/__tests__/useSurveyUseCases.vote.test.ts
  - src/composable/__tests__/useSurveyFilters.test.ts
  - src/composable/__tests__/useAuthUseCases.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "useSurveyUseCases addSurvey, updateSurvey, deleteSurvey, verifySurvey, updateSurveyStatus, updateSurveyVotes each have success + FirestoreError + generic error tests"
    - "Concurrent vote test fires two voteOnSurvey calls simultaneously and verifies both complete"
    - "createFilteredSurveys and createRecentFilteredSurveys return reactive computed refs with correct sorting and limiting"
    - "useAuthUseCases branch coverage hits 70%+ by covering refreshCurrentUser error paths, signOut error paths, getCurrentAuthUser, and cleanup"
  artifacts:
    - path: "src/composable/__tests__/useSurveyUseCases.vote.test.ts"
      provides: "Tests for all 9 useSurveyUseCases functions including concurrent vote scenario"
    - path: "src/composable/__tests__/useSurveyFilters.test.ts"
      provides: "Tests for createFilteredSurveys and createRecentFilteredSurveys computed factories"
    - path: "src/composable/__tests__/useAuthUseCases.test.ts"
      provides: "Additional branch coverage for refreshCurrentUser, signOut errors, getCurrentAuthUser, cleanup"
  key_links:
    - from: "useSurveyUseCases.vote.test.ts"
      to: "useSurveyUseCases.ts"
      via: "mock surveyFirebase methods called by addSurvey/updateSurvey/deleteSurvey/verifySurvey/updateSurveyStatus/updateSurveyVotes"
      pattern: "mock.*\\.toHaveBeenCalledWith"
    - from: "useSurveyFilters.test.ts"
      to: "useSurveyFilters.ts"
      via: "createFilteredSurveys and createRecentFilteredSurveys return computed refs"
      pattern: "createFilteredSurveys|createRecentFilteredSurveys"
---

<objective>
Close coverage gap for useSurveyUseCases.ts (15% → ~80% functions), useSurveyFilters.ts (53% → ~80% functions), and useAuthUseCases.ts branch coverage (53% → ~70%).

Purpose: The phase goal requires 70%+ coverage across all four metrics. These three files are the largest contributors to the deficit on the survey/auth side.
Output: ~40 new tests added to existing test files.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/composable/useSurveyUseCases.ts
@src/composable/useSurveyFilters.ts
@src/composable/useAuthUseCases.ts
@src/composable/__tests__/useSurveyUseCases.vote.test.ts
@src/composable/__tests__/useSurveyFilters.test.ts
@src/composable/__tests__/useAuthUseCases.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tests for remaining useSurveyUseCases functions + concurrent vote + auth branch coverage</name>
  <files>
    src/composable/__tests__/useSurveyUseCases.vote.test.ts
    src/composable/__tests__/useAuthUseCases.test.ts
  </files>
  <action>
**useSurveyUseCases.vote.test.ts** — Add new describe blocks AFTER the existing voteOnSurvey describe block. The mock infrastructure is already in place (mockAddOrUpdateVote, mockGetSurveysByTeamId, and vi.fn() stubs for addSurvey, updateSurvey, deleteSurvey, updateSurveyStatus, verifySurvey, updateSurveyVotes in the surveyFirebase mock). To call the mocked methods by name, extract them as named mock fns at the top (same pattern as mockAddOrUpdateVote):

1. **Extract named mocks** at top of file (alongside existing mockAddOrUpdateVote):
   ```ts
   const mockAddSurvey = vi.fn()
   const mockUpdateSurvey = vi.fn()
   const mockDeleteSurvey = vi.fn()
   const mockUpdateSurveyStatus = vi.fn()
   const mockVerifySurvey = vi.fn()
   const mockUpdateSurveyVotes = vi.fn()
   const mockGetSurveyById = vi.fn()
   ```
   Update the vi.mock('@/services/surveyFirebase') factory to use these named mocks instead of inline vi.fn().

2. **Import authStore** (add `import { useAuthStore } from '@/stores/authStore'` if not present). Several functions (deleteSurvey, verifySurvey) read authStore.user for audit context.

3. **setSurveysListener** (1 test): Call setSurveysListener('team-1'). Verify mockGetSurveysByTeamId called with ('team-1', callback). Verify listenerRegistry.register called with ('surveys', unsubscribe, { teamId: 'team-1' }).

4. **getSurveyById** (1 test): mockGetSurveyById.mockResolvedValue(survey). Call getSurveyById('s1'). Verify it returns the survey.

5. **deleteSurvey** — 4 tests:
   - Success: put survey in teamStore.surveys, set authStore.user. Call deleteSurvey('survey-1'). Verify mockDeleteSurvey called with surveyId and auditContext containing actorUid, actorDisplayName, surveyTitle.
   - Success without user: authStore.user = null. Verify mockDeleteSurvey called with (surveyId, undefined).
   - FirestoreError: mockDeleteSurvey rejects with FirestoreError. Verify notifyError called WITHOUT retry (destructive op). Verify error re-thrown.
   - Generic error: Verify notifyError('errors.unexpected'). Verify error re-thrown.

6. **addSurvey** — 4 tests:
   - Success with team members: Mock `getDoc` (from firebase/firestore, already mocked) to return { exists: () => true, data: () => ({ members: ['u1','u2'] }) }. Mock `doc` to return a ref. Mock mockAddSurvey to return survey data. Call addSurvey(newSurvey). Verify mockAddSurvey called with (newSurvey, ['u1','u2']). Verify createSurveyNotification called.
   - Success with no members: getDoc returns { exists: () => true, data: () => ({}) }. Verify createSurveyNotification NOT called.
   - Success when team doc doesn't exist: getDoc returns { exists: () => false }. Verify mockAddSurvey called with (newSurvey, []).
   - FirestoreError (transient): mockAddSurvey rejects with FirestoreError('unavailable',...). Verify notifyError with retry:true.

7. **updateSurvey** — 3 tests:
   - Success: mockUpdateSurvey resolves. Verify called with (surveyId, partialData).
   - FirestoreError transient: Verify notifyError with retry:true.
   - Generic error: Verify notifyError('errors.unexpected').

8. **updateSurveyStatus** — 3 tests:
   - Success: mockUpdateSurveyStatus resolves. Verify called with (surveyId, status, verifiedBy).
   - FirestoreError transient: retry:true.
   - Generic error: errors.unexpected.

9. **verifySurvey** — 4 tests:
   - Success with user and survey in store: Verify mockVerifySurvey called with (surveyId, verifiedBy, updatedVotes, auditContext).
   - Success without user: auditContext is undefined.
   - FirestoreError transient: retry:true.
   - Generic error: errors.unexpected.

10. **updateSurveyVotes** — 3 tests:
    - Success: Verify called with (surveyId, votes).
    - FirestoreError transient: retry:true.
    - Generic error: errors.unexpected.

11. **Concurrent vote test** (ROADMAP success criterion 2): Fire two voteOnSurvey calls simultaneously using Promise.all:
    ```ts
    it('handles concurrent votes on same survey without data loss', async () => {
      const survey = makeSurvey({ votes: [] })
      teamStore.setSurveys([survey])
      mockAddOrUpdateVote.mockResolvedValue(undefined)

      const { voteOnSurvey } = useSurveyUseCases()
      await Promise.all([
        voteOnSurvey('survey-1', 'user-1', true),
        voteOnSurvey('survey-1', 'user-2', false)
      ])

      expect(mockAddOrUpdateVote).toHaveBeenCalledTimes(2)
      expect(mockAddOrUpdateVote).toHaveBeenCalledWith('survey-1', 'user-1', true, [])
      expect(mockAddOrUpdateVote).toHaveBeenCalledWith('survey-1', 'user-2', false, [])
    })
    ```

**useAuthUseCases.test.ts** — Add tests to cover missing branches (lines 148, 166, 176, 180 = signOut error paths, refreshCurrentUser error paths, getCurrentAuthUser, cleanup):

12. **signOut — FirestoreError branch** (line ~142-149): mockLogoutUser rejects with AuthError('auth/network-request-failed'). Verify notifyError with retry:true and onRetry function.

13. **signOut — generic error**: mockLogoutUser rejects with generic Error. Verify notifyError('errors.unexpected').

14. **refreshCurrentUser — success**: mockRefreshUser resolves with user. Verify authStore.user set.

15. **refreshCurrentUser — AuthError network**: mockRefreshUser rejects with AuthError('auth/network-request-failed'). Verify notifyError with retry:true.

16. **refreshCurrentUser — AuthError non-network**: mockRefreshUser rejects with AuthError('auth/user-not-found'). Verify notifyError with retry:false.

17. **refreshCurrentUser — generic error**: Verify notifyError('errors.unexpected').

18. **getCurrentAuthUser**: mockGetCurrentUser returns user. Verify getCurrentAuthUser() returns same user.

19. **cleanup**: Call cleanup(). Verify authStore.cleanup() was called (spy on the store method).
  </action>
  <verify>Run `npx vitest run src/composable/__tests__/useSurveyUseCases.vote.test.ts src/composable/__tests__/useAuthUseCases.test.ts` — all tests pass with 0 failures.</verify>
  <done>useSurveyUseCases has tests for all 9 exported functions (was 1/9). useAuthUseCases has branch coverage for signOut errors, refreshCurrentUser errors, getCurrentAuthUser, and cleanup. Concurrent vote scenario exists.</done>
</task>

<task type="auto">
  <name>Task 2: Add createFilteredSurveys and createRecentFilteredSurveys tests to useSurveyFilters</name>
  <files>
    src/composable/__tests__/useSurveyFilters.test.ts
  </files>
  <action>
Add new describe blocks to the existing useSurveyFilters.test.ts file. These functions return Vue computed refs, so tests need `ref()` from Vue.

1. **Import ref** from 'vue' at the top of the file.

2. **createFilteredSurveys** — 4 tests:
   - Returns computed that filters and sorts by date ascending:
     ```ts
     const surveys = ref([
       createMockSurvey({ id: '1', date: '2025-09-15', title: 'B' }),
       createMockSurvey({ id: '2', date: '2025-08-01', title: 'A' }),
       createMockSurvey({ id: '3', date: '2025-11-20', title: 'C' }),
     ])
     const { createFilteredSurveys } = useSurveyFilters()
     const result = createFilteredSurveys(surveys)
     expect(result.value.map(s => s.id)).toEqual(['2', '1', '3']) // ascending by date
     ```
   - Reacts to filter changes: Create surveys ref. Get filters ref. Set filters.value.searchName = 'match'. Verify result.value only contains matching surveys.
   - Uses custom filters ref when provided: Pass a separate `customFilters` ref. Verify it uses custom filters instead of internal ones.
   - Reactivity: Change surveys ref value. Verify computed updates.

3. **createRecentFilteredSurveys** — 4 tests:
   - Returns computed sorted by createdDate descending, limited to 5 by default:
     ```ts
     const surveys = ref(Array.from({ length: 8 }, (_, i) =>
       createMockSurvey({ id: `${i}`, createdDate: `${1700000000 + i * 1000}`, date: '2025-10-15' })
     ))
     const { createRecentFilteredSurveys } = useSurveyFilters()
     const result = createRecentFilteredSurveys(surveys)
     expect(result.value).toHaveLength(5)
     expect(result.value[0].id).toBe('7') // newest first
     ```
   - Respects custom limit: Pass limit=3. Verify only 3 returned.
   - Applies filters: Set searchName filter. Verify only matching surveys in result.
   - Handles missing createdDate gracefully: Create surveys with createdDate undefined. Verify no crash, sorts with '0' fallback.
  </action>
  <verify>Run `npx vitest run src/composable/__tests__/useSurveyFilters.test.ts` — all tests pass with 0 failures.</verify>
  <done>createFilteredSurveys and createRecentFilteredSurveys have tests covering sorting, limiting, reactivity, and custom filters. useSurveyFilters function coverage rises from 53% to ~80%.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/composable/__tests__/useSurveyUseCases.vote.test.ts` — all pass
2. `npx vitest run src/composable/__tests__/useAuthUseCases.test.ts` — all pass
3. `npx vitest run src/composable/__tests__/useSurveyFilters.test.ts` — all pass
4. `npx vitest run --coverage` — check useSurveyUseCases.ts functions > 70%, useSurveyFilters.ts functions > 70%, useAuthUseCases.ts branch > 65%
</verification>

<success_criteria>
- useSurveyUseCases.ts function coverage rises from 15% to ~80% (all 9 functions tested)
- useSurveyFilters.ts function coverage rises from 53% to ~80% (all functions tested)
- useAuthUseCases.ts branch coverage rises from 53% toward 70%
- Concurrent vote scenario test exists and passes
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-test-implementation/08-04-SUMMARY.md`
</output>
