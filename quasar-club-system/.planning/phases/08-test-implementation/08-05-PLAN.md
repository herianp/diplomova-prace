---
phase: 08-test-implementation
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/composable/__tests__/useCashboxUseCases.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "useCashboxUseCases addFineRule, updateFineRule, deleteFineRule each have success + error tests"
    - "useCashboxUseCases addManualFine and deleteFine tests cover audit context construction from authStore"
    - "useCashboxUseCases recordPayment and deletePayment have success + error tests"
    - "useCashboxUseCases calculatePlayerBalance, calculateAllPlayerBalances, calculateTeamSummary return correct calculations"
    - "useCashboxUseCases listener passthrough functions are covered"
  artifacts:
    - path: "src/composable/__tests__/useCashboxUseCases.test.ts"
      provides: "Tests for all 16 useCashboxUseCases functions"
  key_links:
    - from: "useCashboxUseCases.test.ts"
      to: "useCashboxUseCases.ts"
      via: "mock cashboxFirebase methods called by CRUD functions + pure calculation tests"
      pattern: "mock.*\\.toHaveBeenCalledWith|calculatePlayerBalance|calculateTeamSummary"
---

<objective>
Close coverage gap for useCashboxUseCases.ts (12.5% → ~75% functions) by testing CRUD operations, listener passthroughs, and pure calculation functions.

Purpose: useCashboxUseCases.ts has 16 functions but only generateAutoFines is tested. The 15 untested functions are the largest single contributor to the global coverage deficit.
Output: ~35 new tests added to the existing useCashboxUseCases.test.ts file.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/composable/useCashboxUseCases.ts
@src/composable/__tests__/useCashboxUseCases.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CRUD operation and listener tests to useCashboxUseCases</name>
  <files>
    src/composable/__tests__/useCashboxUseCases.test.ts
  </files>
  <action>
The existing test file already has vi.mock('@/services/cashboxFirebase') with vi.fn() stubs for ALL methods. Extract named mocks for the methods we need to assert on:

1. **Extract named mocks** at the top (alongside existing mockLoadFineRules and mockBulkAddFines):
   ```ts
   const mockAddFineRule = vi.fn()
   const mockUpdateFineRule = vi.fn()
   const mockDeleteFineRule = vi.fn()
   const mockAddFine = vi.fn()
   const mockDeleteFine = vi.fn()
   const mockAddPayment = vi.fn()
   const mockDeletePayment = vi.fn()
   const mockListenToFineRules = vi.fn()
   const mockListenToFines = vi.fn()
   const mockListenToPayments = vi.fn()
   const mockListenToCashboxHistory = vi.fn()
   ```
   Update the vi.mock('@/services/cashboxFirebase') factory to use these named mocks.

2. **Import** useAuthStore from '@/stores/authStore'. Add `import { FirestoreError } from '@/errors'` if not present. Add `import { IFine, IPayment } from '@/interfaces/interfaces'`.

3. **Add authStore setup** to beforeEach: set authStore with a mock user `{ uid: 'admin-uid', displayName: 'Admin', email: 'admin@test.cz' }`.

**Listener passthroughs** — 4 tests (new describe block 'listeners'):
- listenToFineRules: calls cashboxFirebase.listenToFineRules with (teamId, callback) and returns unsubscribe.
- listenToFines: same pattern.
- listenToPayments: same pattern.
- listenToCashboxHistory: same pattern.
For each: mockListenToX returns a vi.fn(). Call the use case function. Verify mock called with args. Verify return value is the unsubscribe.

**addFineRule** — 3 tests (new describe block 'addFineRule'):
- Success: mockAddFineRule resolves. Call addFineRule('team-1', ruleData). Verify mockAddFineRule called with ('team-1', ruleData).
- FirestoreError transient (unavailable): mockAddFineRule rejects with FirestoreError('unavailable', 'write', 'Unavailable'). Verify notifyError with retry:true. Verify re-throw.
- Generic error: Verify notifyError('errors.unexpected'). Verify re-throw.

**updateFineRule** — 3 tests:
- Success: Verify called with ('team-1', 'rule-1', partialData).
- FirestoreError transient: retry:true.
- Generic error: errors.unexpected.

**deleteFineRule** — 3 tests:
- Success: Verify called with ('team-1', 'rule-1').
- FirestoreError: Verify notifyError called WITHOUT retry (destructive op — no retry/onRetry options).
- Generic error: errors.unexpected.

**addManualFine** — 4 tests (new describe block 'addManualFine'):
- Success with authStore.user: Call addManualFine('team-1', 'player-1', 100, 'Late', 'admin-uid'). Verify mockAddFine called with ('team-1', fineObj, auditContext). Verify fineObj has: playerId='player-1', amount=100, reason='Late', source='manual', createdBy='admin-uid'. Verify auditContext has: actorUid='admin-uid', actorDisplayName='Admin'.
- Success without authStore.user: Set authStore user to null. Verify mockAddFine called with ('team-1', fineObj, undefined).
- FirestoreError transient: retry:true.
- Generic error: errors.unexpected.

**deleteFine** — 4 tests (new describe block 'deleteFine'):
- Success with user and fine object: Call deleteFine('team-1', 'fine-1', { amount: 50, reason: 'Late' } as IFine). Verify mockDeleteFine called with ('team-1', 'fine-1', auditContext). auditContext should include fineAmount=50, fineReason='Late'.
- Success without user: auditContext is undefined.
- Success without fine object: Call deleteFine('team-1', 'fine-1'). auditContext is undefined even if user exists (because `authStore.user && fine` is false).
- FirestoreError: No retry (destructive).

**recordPayment** — 4 tests (new describe block 'recordPayment'):
- Success with note: Call recordPayment('team-1', 'player-1', 200, 'admin-uid', 'Monthly'). Verify mockAddPayment called with ('team-1', paymentObj). paymentObj must have: playerId, amount=200, createdBy, note='Monthly'.
- Success without note: Verify payment object does NOT have note field.
- FirestoreError transient: retry:true.
- Generic error: errors.unexpected.

**deletePayment** — 3 tests:
- Success: Verify called with ('team-1', 'payment-1').
- FirestoreError: No retry (destructive).
- Generic error: errors.unexpected.
  </action>
  <verify>Run `npx vitest run src/composable/__tests__/useCashboxUseCases.test.ts` — all tests pass.</verify>
  <done>All CRUD operations, listener passthroughs, and error handling paths for useCashboxUseCases are tested. Function coverage for CRUD+listener portion rises significantly.</done>
</task>

<task type="auto">
  <name>Task 2: Add pure calculation function tests to useCashboxUseCases</name>
  <files>
    src/composable/__tests__/useCashboxUseCases.test.ts
  </files>
  <action>
Add describe blocks for the three pure calculation functions. These require NO mocks — they are pure functions operating on arrays.

**calculatePlayerBalance** — 5 tests (new describe block 'calculatePlayerBalance'):
- Player with fines and payments: fines=[{playerId:'p1', amount:100}, {playerId:'p1', amount:50}], payments=[{playerId:'p1', amount:75}]. Expect: totalFined=150, totalPaid=75, balance=-75.
- Player with no fines: fines=[], payments=[{playerId:'p1', amount:50}]. Expect: totalFined=0, totalPaid=50, balance=50.
- Player with no payments: fines=[{playerId:'p1', amount:100}], payments=[]. Expect: totalFined=100, totalPaid=0, balance=-100.
- Player with zero balance: fines=[{amount:50}], payments=[{amount:50}]. Expect: balance=0.
- Ignores other players' data: fines include other playerId entries. Verify they are excluded.

**calculateAllPlayerBalances** — 3 tests (new describe block 'calculateAllPlayerBalances'):
- Returns sorted by balance ascending (most in debt first): memberIds=['p1','p2','p3']. p1 balance=50, p2 balance=-100, p3 balance=0. Expect order: [p2, p3, p1].
- Uses getDisplayName callback: Verify each player's displayName comes from the callback.
- Empty members list: Returns [].

**calculateTeamSummary** — 4 tests (new describe block 'calculateTeamSummary'):
- Basic summary: 2 players, various fines/payments. Verify totalFined, totalPaid, totalOutstanding, totalCredits, totalFinesCount.
- Player with overpayment creates credit: Player paid more than fined. Verify totalCredits includes their surplus. Verify totalOutstanding does NOT offset.
- Empty fines and payments: All zeros.
- Single player with exact payment: totalOutstanding=0, totalCredits=0.

For test data, create minimal IFine and IPayment objects with required fields:
```ts
const makeFine = (playerId: string, amount: number): IFine => ({
  id: `fine-${playerId}-${amount}`,
  playerId,
  amount,
  reason: 'Test',
  source: 'manual' as const,
  createdBy: 'admin',
  createdAt: new Date(),
})

const makePayment = (playerId: string, amount: number): IPayment => ({
  id: `pay-${playerId}-${amount}`,
  playerId,
  amount,
  createdBy: 'admin',
  createdAt: new Date(),
})
```
  </action>
  <verify>Run `npx vitest run src/composable/__tests__/useCashboxUseCases.test.ts` — all tests pass including both Task 1 and Task 2 additions.</verify>
  <done>calculatePlayerBalance, calculateAllPlayerBalances, and calculateTeamSummary have comprehensive tests covering calculations, sorting, edge cases. useCashboxUseCases function coverage rises from 12.5% to ~75%.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/composable/__tests__/useCashboxUseCases.test.ts` — all tests pass
2. `npx vitest run --coverage` — check useCashboxUseCases.ts functions > 70%, statements > 70%
</verification>

<success_criteria>
- useCashboxUseCases.ts function coverage rises from 12.5% to ~75% (12+ of 16 functions tested)
- useCashboxUseCases.ts statement coverage rises from 29% to ~75%
- All CRUD operations have success + error path tests
- Pure calculation functions have correctness tests
- All existing generateAutoFines tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-test-implementation/08-05-SUMMARY.md`
</output>
