---
phase: 03-code-quality-typescript
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - package.json
  - src/utils/logger.ts
  - src/boot/errorHandler.ts
  - src/services/authFirebase.ts
  - src/services/teamFirebase.ts
  - src/services/surveyFirebase.ts
  - src/services/cashboxFirebase.ts
  - src/services/notificationFirebase.ts
  - src/services/messageFirebase.ts
  - src/services/listenerRegistry.ts
autonomous: true

must_haves:
  truths:
    - "Developer sees structured log entries with context (operation name, error code) instead of raw console.error in service layer"
    - "Log levels are respected: debug/info in development, error-only in production"
  artifacts:
    - path: "src/utils/logger.ts"
      provides: "Centralized logger utility with context enrichment"
      exports: ["logger", "createLogger"]
      min_lines: 20
    - path: "src/services/authFirebase.ts"
      provides: "Auth service with structured logging"
    - path: "src/services/surveyFirebase.ts"
      provides: "Survey service with structured logging"
  key_links:
    - from: "src/services/authFirebase.ts"
      to: "src/utils/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from.*utils/logger"
    - from: "src/services/teamFirebase.ts"
      to: "src/utils/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from.*utils/logger"
---

<objective>
Create a structured logging utility and migrate all service layer files from raw console.error/warn/log to structured logging with context.

Purpose: Replace raw console output with structured, context-rich logging that includes operation names, error codes, and entity IDs (QAL-02, service layer).
Output: Logger utility module, 8 service files migrated from console to structured logger.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-code-quality-typescript/03-RESEARCH.md
@src/services/authFirebase.ts
@src/services/listenerRegistry.ts
@src/boot/errorHandler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structured logger utility</name>
  <files>
    src/utils/logger.ts
  </files>
  <action>
Create a lightweight structured logging utility at `src/utils/logger.ts`. Do NOT use vuejs3-logger (it requires Vue app.use() and inject, making it unusable in plain TypeScript service files that run outside Vue component context). Instead, create a simple custom logger that wraps console methods with structured context.

Research note: vuejs3-logger was recommended but it requires Vue component context (this.$log or inject). Our services are plain TypeScript files, not Vue components. A lightweight wrapper is the right choice here.

```typescript
type LogLevel = 'debug' | 'info' | 'warn' | 'error'

interface LogContext {
  [key: string]: unknown
}

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
}

const currentLevel: LogLevel = import.meta.env.PROD ? 'error' : 'debug'

function shouldLog(level: LogLevel): boolean {
  return LOG_LEVELS[level] >= LOG_LEVELS[currentLevel]
}

function formatMessage(level: LogLevel, message: string, context?: LogContext): string {
  const timestamp = new Date().toISOString()
  const prefix = `[${timestamp}] [${level.toUpperCase()}]`
  return context
    ? `${prefix} ${message} ${JSON.stringify(context)}`
    : `${prefix} ${message}`
}

export const logger = {
  debug(message: string, context?: LogContext): void {
    if (shouldLog('debug')) console.debug(formatMessage('debug', message, context))
  },
  info(message: string, context?: LogContext): void {
    if (shouldLog('info')) console.info(formatMessage('info', message, context))
  },
  warn(message: string, context?: LogContext): void {
    if (shouldLog('warn')) console.warn(formatMessage('warn', message, context))
  },
  error(message: string, context?: LogContext): void {
    if (shouldLog('error')) console.error(formatMessage('error', message, context))
  }
}

/**
 * Create a scoped logger that automatically includes a service/module name in context
 */
export function createLogger(scope: string) {
  return {
    debug: (msg: string, ctx?: LogContext) => logger.debug(msg, { scope, ...ctx }),
    info: (msg: string, ctx?: LogContext) => logger.info(msg, { scope, ...ctx }),
    warn: (msg: string, ctx?: LogContext) => logger.warn(msg, { scope, ...ctx }),
    error: (msg: string, ctx?: LogContext) => logger.error(msg, { scope, ...ctx }),
  }
}
```

Key design decisions:
- No external dependency — lightweight wrapper around console with structured output
- `createLogger('serviceName')` returns scoped logger that auto-tags with module name
- Production mode: only errors logged. Development: all levels
- JSON context enables future log aggregation if needed
- Works in plain TypeScript (no Vue dependency)
  </action>
  <verify>Run `npx tsc --noEmit` — logger.ts compiles without errors.</verify>
  <done>Structured logger utility exists at src/utils/logger.ts with debug/info/warn/error levels and createLogger for scoped logging.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate service layer and errorHandler to structured logging</name>
  <files>
    src/boot/errorHandler.ts
    src/services/authFirebase.ts
    src/services/teamFirebase.ts
    src/services/surveyFirebase.ts
    src/services/cashboxFirebase.ts
    src/services/notificationFirebase.ts
    src/services/messageFirebase.ts
    src/services/listenerRegistry.ts
  </files>
  <action>
For each service file, apply this pattern:

1. Add import at top: `import { createLogger } from 'src/utils/logger'`
2. Create scoped logger: `const log = createLogger('authFirebase')` (use file name as scope)
3. Replace every `console.error(...)` with `log.error(message, { context })`:

   **Pattern for error catches:**
   ```typescript
   // BEFORE:
   console.error('Error creating survey:', error)

   // AFTER:
   log.error('Failed to create survey', { error: error instanceof Error ? error.message : String(error), teamId })
   ```

   **Pattern for warnings:**
   ```typescript
   // BEFORE:
   console.warn('User not found:', userId)

   // AFTER:
   log.warn('User not found', { userId })
   ```

   **Pattern for debug/info logging:**
   ```typescript
   // BEFORE:
   console.log('Listener registered:', key)

   // AFTER:
   log.debug('Listener registered', { key })
   ```

4. Include relevant context in each log call. Context should include the entity IDs available in scope (teamId, surveyId, userId, etc.) and operation-specific details. Do NOT log sensitive data (passwords, tokens).

5. Specific files and their console counts:
   - `src/services/cashboxFirebase.ts` — 17 occurrences (largest)
   - `src/services/teamFirebase.ts` — 11 occurrences
   - `src/services/surveyFirebase.ts` — 9 occurrences
   - `src/services/authFirebase.ts` — 6 occurrences
   - `src/services/notificationFirebase.ts` — 6 occurrences
   - `src/services/listenerRegistry.ts` — 6 occurrences
   - `src/services/messageFirebase.ts` — 2 occurrences
   - `src/boot/errorHandler.ts` — 1 occurrence

6. After migration, verify NO raw `console.error`, `console.warn`, or `console.log` calls remain in these files. The ONLY console usage should be inside `src/utils/logger.ts` itself.
  </action>
  <verify>Run `grep -r "console\." src/services/ src/boot/errorHandler.ts` — must return zero matches. Run `npx tsc --noEmit` — zero errors. Run `npx quasar dev` — app starts and operations log structured output in browser console.</verify>
  <done>All 8 service/boot files migrated from raw console to structured logger. 58 console calls replaced with context-rich structured logging.</done>
</task>

</tasks>

<verification>
- `src/utils/logger.ts` exists and exports `logger` and `createLogger`
- Zero `console.error/warn/log` calls in `src/services/*.ts` and `src/boot/errorHandler.ts`
- `npx tsc --noEmit` passes
- App runs and structured logs appear in browser DevTools console
</verification>

<success_criteria>
All service layer files use structured logging with context (operation name, entity IDs, error details). Raw console calls eliminated from services. Logger respects log levels (error-only in production).
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-quality-typescript/03-03-SUMMARY.md`
</output>
