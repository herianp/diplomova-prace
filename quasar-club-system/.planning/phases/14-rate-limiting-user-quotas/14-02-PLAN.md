---
phase: 14-rate-limiting-user-quotas
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/composable/useRateLimiter.ts
  - src/composable/useTeamUseCases.ts
  - src/composable/useSurveyUseCases.ts
  - src/composable/useJoinRequestUseCases.ts
  - src/composable/useCashboxUseCases.ts
  - src/components/onboarding/CreateTeamForm.vue
  - src/components/team/JoinRequestManagement.vue
  - src/i18n/cs.json
  - src/i18n/en.json
autonomous: true
requirements:
  - RATE-02
  - RATE-03

must_haves:
  truths:
    - "User who exceeds team creation limit sees a disabled button with tooltip explaining the limit"
    - "User who exceeds weekly message limit is blocked from sending and sees reset info"
    - "User who exceeds weekly survey limit cannot create surveys and sees reset info"
    - "User who has max pending join requests cannot send more until one resolves"
    - "Team that exceeds daily fine limit cannot create fines until next day"
    - "Rate limits are enforced client-side before the action reaches Firestore"
  artifacts:
    - path: "src/composable/useRateLimiter.ts"
      provides: "Central composable that checks any action against config + usage"
      exports: ["useRateLimiter"]
  key_links:
    - from: "src/composable/useRateLimiter.ts"
      to: "src/stores/rateLimitStore.ts"
      via: "reads config from store"
      pattern: "useRateLimitStore"
    - from: "src/composable/useRateLimiter.ts"
      to: "src/services/rateLimitFirebase.ts"
      via: "reads/increments usage counters"
      pattern: "useRateLimitFirebase"
    - from: "src/composable/useTeamUseCases.ts"
      to: "src/composable/useRateLimiter.ts"
      via: "checks limit before createTeam"
      pattern: "useRateLimiter|checkLimit"
---

<objective>
Create the rate limit enforcement composable and integrate it into all 5 rate-limited actions across the app. Add user-facing feedback (disabled buttons, tooltips with reset info).

Purpose: Users who exceed limits are blocked with clear feedback; honest users see limits enforced client-side.
Output: `useRateLimiter` composable wired into team creation, messages, join requests, surveys, and fines.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-rate-limiting-user-quotas/14-CONTEXT.md
@.planning/phases/14-rate-limiting-user-quotas/14-01-SUMMARY.md
@src/interfaces/interfaces.ts
@src/composable/useTeamUseCases.ts
@src/composable/useSurveyUseCases.ts
@src/composable/useJoinRequestUseCases.ts
@src/composable/useCashboxUseCases.ts
@src/services/messageFirebase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRateLimiter composable with check/increment logic</name>
  <files>
    src/composable/useRateLimiter.ts
  </files>
  <action>
Create `src/composable/useRateLimiter.ts` — the central enforcement composable.

**Core function: `checkLimit(action, context?)`**
- Reads config from `useRateLimitStore`
- Reads current usage from Firebase (user doc or team doc depending on action)
- For time-windowed limits (weekly/daily): checks if the window has expired. If expired, resets counter via firebase service before checking.
- Returns `{ allowed: boolean, current: number, limit: number, resetInfo: string | null }`
  - `resetInfo` examples: "Resets on Monday" (weekly), "Resets tomorrow" (daily), "This limit is permanent" (total), "Resolve pending requests first" (concurrent)

**Core function: `incrementUsage(action, context?)`**
- Called AFTER a successful action to bump the counter
- For user-scoped actions (teamCreation, messages, surveys): increments on user document `usage.{field}`
- For team-scoped actions (fines): increments on team document `usage.{field}`
- For concurrent (joinRequests): no increment needed — count is derived from pending request query

**Action mapping:**
```ts
const actionConfig = {
  teamCreation: { scope: 'user', field: 'teamsCreated', windowType: 'total' },
  messages: { scope: 'user', field: 'messagesThisWeek', weekStartField: 'messagesWeekStart', windowType: 'weekly' },
  joinRequests: { scope: 'user', field: 'pendingJoinRequests', windowType: 'concurrent' },
  surveys: { scope: 'user', field: 'surveysThisWeek', weekStartField: 'surveysWeekStart', windowType: 'weekly' },
  fines: { scope: 'team', field: 'finesToday', dateStartField: 'finesDateStart', windowType: 'daily' },
}
```

**Weekly window check:** Compare stored `weekStart` to current Monday. If current Monday > stored weekStart, window has expired — reset counter to 0 and update weekStart to current Monday. Use Luxon `DateTime.now().startOf('week')` for Monday calculation.

**Daily window check:** Compare stored `dateStart` to today. If today > stored dateStart, reset counter to 0 and update dateStart.

**Concurrent check (joinRequests):** Query Firestore for user's pending join requests count. Do NOT use a stored counter — derive from actual data.

**Helper: `formatResetInfo(windowType, weekStart?, dateStart?)`**
- `total` -> i18n key `rateLimits.resetPermanent` ("This limit is permanent")
- `weekly` -> i18n key `rateLimits.resetWeekly` with interpolated next Monday date
- `daily` -> i18n key `rateLimits.resetDaily` ("Resets tomorrow" or "Resets at midnight")
- `concurrent` -> i18n key `rateLimits.resetConcurrent` ("Resolve pending requests first")

**Reactive helper: `useActionLimitStatus(action, context?)`**
- Returns `{ isLimited: Ref<boolean>, limitInfo: Ref<string>, current: Ref<number>, limit: Ref<number> }`
- Calls `checkLimit` on mount and exposes reactive refs for template binding
- Used by UI components for button disabling and tooltip content
  </action>
  <verify>
    TypeScript compilation: `cd C:/Users/Developer/Documents/projekty/diplomova-prace/quasar-club-system && npx vue-tsc --noEmit 2>&1 | head -20` shows no errors.
  </verify>
  <done>
    useRateLimiter composable exports `checkLimit`, `incrementUsage`, `formatResetInfo`, and `useActionLimitStatus`. All 5 action types are mapped with correct scope, field names, and window types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire enforcement into all 5 actions and add UI feedback</name>
  <files>
    src/composable/useTeamUseCases.ts
    src/composable/useSurveyUseCases.ts
    src/composable/useJoinRequestUseCases.ts
    src/composable/useCashboxUseCases.ts
    src/services/messageFirebase.ts
    src/components/onboarding/CreateTeamForm.vue
    src/components/team/JoinRequestManagement.vue
    src/i18n/cs.json
    src/i18n/en.json
  </files>
  <action>
**Enforcement integration (use cases):**

1. `useTeamUseCases.ts` — in `createTeam()`:
   - Before the firebase call, call `checkLimit('teamCreation')`. If `!allowed`, throw a user-friendly error and return early (do NOT call firebase).
   - After successful creation, call `incrementUsage('teamCreation')`.

2. `useSurveyUseCases.ts` — in the survey creation function:
   - Before creating, call `checkLimit('surveys')`. Block if exceeded.
   - After success, call `incrementUsage('surveys')`.

3. `useJoinRequestUseCases.ts` — in the send join request function:
   - Before sending, call `checkLimit('joinRequests')`. Block if exceeded (concurrent pending count).
   - No increment needed — pending count is derived from query.

4. `useCashboxUseCases.ts` — in the fine creation function:
   - Before creating, call `checkLimit('fines', { teamId })`. Block if exceeded.
   - After success, call `incrementUsage('fines', { teamId })`.

5. `src/services/messageFirebase.ts` — in the send message function:
   - Before sending, call `checkLimit('messages')`. Block if exceeded.
   - After success, call `incrementUsage('messages')`.

For all blocked actions, use `notifyError()` with the `limitInfo` string from `checkLimit` result, so the user sees a toast explaining the limit and reset time.

**UI feedback (button disabling + tooltips):**

6. `src/components/onboarding/CreateTeamForm.vue`:
   - Use `useActionLimitStatus('teamCreation')` to get reactive `isLimited` and `limitInfo`.
   - Add `:disable="isLimited"` to the create team button.
   - Wrap button in `q-tooltip` that shows `limitInfo` when `isLimited` is true: `<q-tooltip v-if="isLimited">{{ limitInfo }}</q-tooltip>`.

7. For other actions where there are visible "create" buttons (survey creation dialog, message send button, fine creation), apply the same pattern: `useActionLimitStatus` for the relevant action, disable button, show tooltip. Identify these buttons by reading the relevant component templates and adding the disable + tooltip pattern. If a component uses a dialog/modal for creation, the disable goes on the dialog's submit button.

**i18n keys** (add to both cs.json and en.json under `rateLimits`):
- `exceeded`: "Limit reached" / "Limit dosažen"
- `resetPermanent`: "This limit is permanent" / "Tento limit je trvalý"
- `resetWeekly`: "Resets on {date}" / "Obnoví se {date}"
- `resetDaily`: "Resets tomorrow" / "Obnoví se zítra"
- `resetConcurrent`: "Resolve pending requests first" / "Nejprve vyřešte čekající žádosti"
- `teamCreationExceeded`: "You've created the maximum number of teams ({limit})" / "Vytvořili jste maximální počet týmů ({limit})"
- `messagesExceeded`: "Weekly message limit reached ({current}/{limit})" / "Týdenní limit zpráv dosažen ({current}/{limit})"
- `surveysExceeded`: "Weekly survey limit reached ({current}/{limit})" / "Týdenní limit anket dosažen ({current}/{limit})"
- `joinRequestsExceeded`: "Maximum pending join requests reached ({limit})" / "Dosažen maximální počet čekajících žádostí ({limit})"
- `finesExceeded`: "Daily fine limit reached for this team ({current}/{limit})" / "Denní limit pokut pro tento tým dosažen ({current}/{limit})"
  </action>
  <verify>
    1. TypeScript compiles: `npx vue-tsc --noEmit`
    2. Manual test: create teams until limit is reached — button becomes disabled, tooltip shows "This limit is permanent"
    3. Verify that all 5 action types show toast notification when limit is exceeded
  </verify>
  <done>
    All 5 rate-limited actions check limits before execution. Exceeded limits block the action with a user-facing toast. Create Team button (and other relevant buttons) disable with explanatory tooltips when limits are reached. Reset timing info is displayed for time-windowed limits.
  </done>
</task>

</tasks>

<verification>
1. Team creation: create teams until limit (default 5) — 6th attempt blocked with toast + disabled button
2. Messages: send 50 messages in a week — 51st blocked with weekly reset info
3. Surveys: create 10 surveys in a week — 11th blocked
4. Join requests: send 5 pending join requests — 6th blocked until one resolves
5. Fines: create 500 fines in one team in one day — 501st blocked with "Resets tomorrow"
6. Admin changes a limit — enforcement picks up the new value via real-time listener
</verification>

<success_criteria>
- useRateLimiter composable handles all 5 action types with correct window logic
- All 5 actions check limits before execution and increment after success
- Buttons disable with tooltips when limits are reached
- Toast notifications explain the limit and reset timing
- Weekly/daily counters auto-reset when their window expires
</success_criteria>

<output>
After completion, create `.planning/phases/14-rate-limiting-user-quotas/14-02-SUMMARY.md`
</output>
