---
phase: 12-team-discovery-join-requests
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/interfaces/interfaces.ts
  - src/services/joinRequestFirebase.ts
  - src/composable/useJoinRequestUseCases.ts
  - firestore.rules
autonomous: true
requirements:
  - DISC-01
  - DISC-02

must_haves:
  truths:
    - "A new joinRequests Firestore collection exists with security rules that allow authenticated users to create requests and team power users to read/update them"
    - "IJoinRequest interface defines the join request data model with status lifecycle"
    - "Firebase service provides CRUD operations for join requests including getAllTeams query"
    - "Use case layer enforces max 5 pending requests per user and prevents duplicate requests"
  artifacts:
    - path: "src/interfaces/interfaces.ts"
      provides: "IJoinRequest interface and updated AuditOperation type"
      contains: "IJoinRequest"
    - path: "src/services/joinRequestFirebase.ts"
      provides: "Firebase operations for join requests and team browsing"
      exports: ["useJoinRequestFirebase"]
    - path: "src/composable/useJoinRequestUseCases.ts"
      provides: "Business logic for join requests with validation"
      exports: ["useJoinRequestUseCases"]
    - path: "firestore.rules"
      provides: "Security rules for joinRequests collection and teams read-all"
      contains: "joinRequests"
  key_links:
    - from: "src/composable/useJoinRequestUseCases.ts"
      to: "src/services/joinRequestFirebase.ts"
      via: "composable calls firebase service"
      pattern: "useJoinRequestFirebase\\(\\)"
    - from: "src/services/joinRequestFirebase.ts"
      to: "firestore.rules"
      via: "firebase operations governed by security rules"
      pattern: "joinRequests"
---

<objective>
Create the data layer for team discovery and join requests: Firestore collection, security rules, Firebase service, and use case orchestration.

Purpose: Establishes the foundation that all UI plans depend on — the IJoinRequest interface, joinRequests Firestore collection with proper security rules, a Firebase service for all join request and team browsing operations, and a use case layer enforcing business rules (max 5 pending, no duplicates).

Output: Working data layer ready for UI consumption in plans 02-04.
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-team-discovery-join-requests/12-CONTEXT.md
@src/interfaces/interfaces.ts
@src/services/teamFirebase.ts
@src/composable/useTeamUseCases.ts
@src/services/auditLogFirebase.ts
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IJoinRequest interface, update AuditOperation, and create joinRequestFirebase service</name>
  <files>
    src/interfaces/interfaces.ts
    src/services/joinRequestFirebase.ts
  </files>
  <action>
**1. In `src/interfaces/interfaces.ts`:**

Add `IJoinRequest` interface in a new "Join Requests" section after the Team section:

```typescript
export interface IJoinRequest {
  id?: string
  userId: string
  userDisplayName: string
  userEmail: string
  teamId: string
  teamName: string
  status: 'pending' | 'approved' | 'declined' | 'cancelled'
  createdAt: Date
  respondedAt?: Date
  respondedBy?: string
  respondedByName?: string
}
```

Update the `AuditOperation` type to add join request operations:
```typescript
| 'joinRequest.approve'
| 'joinRequest.decline'
```

**2. Create `src/services/joinRequestFirebase.ts`:**

Follow the existing `useTeamFirebase()` pattern. Export `useJoinRequestFirebase()` returning:

- `getAllTeams(callback, onError?)` — real-time listener on the `teams` collection (no filter, returns all teams). Maps docs to `ITeam[]`. Returns `Unsubscribe`. This is needed for the browse list.

- `getJoinRequestsByUser(userId, callback, onError?)` — real-time listener on `joinRequests` where `userId == userId`. Returns `Unsubscribe`. Needed for badge states and "My Requests".

- `getJoinRequestsByTeam(teamId, callback, onError?)` — real-time listener on `joinRequests` where `teamId == teamId` and `status == 'pending'`. Returns `Unsubscribe`. Needed for power user request management.

- `createJoinRequest(data: Omit<IJoinRequest, 'id'>)` — `addDoc` to `joinRequests` collection.

- `updateJoinRequestStatus(requestId, status, respondedBy, respondedByName)` — `updateDoc` setting status, respondedAt (new Date()), respondedBy, respondedByName.

- `cancelJoinRequest(requestId)` — `updateDoc` setting status to 'cancelled'.

- `countPendingRequestsByUser(userId)` — `getDocs` query on `joinRequests` where userId and status=='pending', returns count.

- `addMemberToTeam(teamId, userId)` — `updateDoc` on team doc using `arrayUnion(userId)` to add user to `members` array. This is the approval action.

Use `mapFirestoreError` and `createLogger('joinRequestFirebase')` consistent with existing services. Import from `@/errors/errorMapper` and `src/utils/logger`.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to confirm no new TypeScript errors in the new files. Check that `src/services/joinRequestFirebase.ts` exists and exports `useJoinRequestFirebase`.
  </verify>
  <done>IJoinRequest interface exists in interfaces.ts. joinRequestFirebase.ts exports useJoinRequestFirebase with all 8 methods. No TypeScript compilation errors in new files.</done>
</task>

<task type="auto">
  <name>Task 2: Create useJoinRequestUseCases composable and update Firestore security rules</name>
  <files>
    src/composable/useJoinRequestUseCases.ts
    firestore.rules
  </files>
  <action>
**1. Create `src/composable/useJoinRequestUseCases.ts`:**

Follow the `useTeamUseCases` pattern. Export `useJoinRequestUseCases()` returning:

- `sendJoinRequest(teamId, teamName)` — Gets current user from authStore. Validates: (a) user has fewer than 5 pending requests via `countPendingRequestsByUser`, (b) user is not already a member of the team (check `teamStore.teams`). Creates IJoinRequest with status 'pending', userId, userDisplayName (from authStore.user.displayName or email), userEmail, teamId, teamName, createdAt. Throws descriptive errors for validation failures. Uses `notifyError` for Firestore errors.

- `cancelJoinRequest(requestId)` — Calls firebase service `cancelJoinRequest`. Error handling with notifyError.

- `approveJoinRequest(request: IJoinRequest)` — Calls `addMemberToTeam(request.teamId, request.userId)` then `updateJoinRequestStatus(request.id, 'approved', currentUser.uid, currentUser.displayName)`. Writes audit log via `useAuditLogFirebase().writeAuditLog()` with operation 'joinRequest.approve', entityType 'member', entityId request.userId. Error handling with notifyError.

- `declineJoinRequest(request: IJoinRequest)` — Calls `updateJoinRequestStatus(request.id, 'declined', currentUser.uid, currentUser.displayName)`. Writes audit log with operation 'joinRequest.decline'. Error handling with notifyError.

- `setAllTeamsListener(callback)` — Delegates to `joinRequestFirebase.getAllTeams(callback)`. Returns Unsubscribe.

- `setUserJoinRequestsListener(callback)` — Gets userId from authStore, delegates to `joinRequestFirebase.getJoinRequestsByUser(userId, callback)`. Returns Unsubscribe.

- `setTeamJoinRequestsListener(teamId, callback)` — Delegates to `joinRequestFirebase.getJoinRequestsByTeam(teamId, callback)`. Returns Unsubscribe.

**2. Update `firestore.rules`:**

Add a new rule block for `joinRequests` collection AFTER the `teamInvitations` block:

```
// Join requests - users can request to join teams
match /joinRequests/{requestId} {
  // Any authenticated user can create a join request (as themselves)
  allow create: if request.auth != null &&
    request.resource.data.userId == request.auth.uid;

  // Users can read their own join requests
  allow read: if request.auth != null &&
    resource.data.userId == request.auth.uid;

  // Power users can read join requests for their team
  allow read: if request.auth != null &&
    resource.data.teamId != null &&
    exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
    get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data.powerusers.hasAny([request.auth.uid]);

  // Users can cancel their own pending requests
  allow update: if request.auth != null &&
    resource.data.userId == request.auth.uid &&
    resource.data.status == 'pending' &&
    request.resource.data.status == 'cancelled';

  // Power users can approve or decline pending requests for their team
  allow update: if request.auth != null &&
    resource.data.teamId != null &&
    resource.data.status == 'pending' &&
    request.resource.data.status in ['approved', 'declined'] &&
    exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
    get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data.powerusers.hasAny([request.auth.uid]);

  // App admin full access
  allow read, delete: if isAppAdmin();
}
```

Also add a rule allowing ANY authenticated user to read the teams collection (for browsing). Add this BEFORE the existing `match /teams/{teamId}` block, or add an additional allow rule inside it:

Inside the existing `match /teams/{teamId}` block, add:
```
// Allow any authenticated user to read teams for browsing
allow read: if request.auth != null;
```

This must be placed so it doesn't conflict with existing rules. Since Firestore uses OR logic for allow rules, adding this line grants browse access to all authenticated users regardless of membership.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to confirm no TypeScript errors. Verify `firestore.rules` is syntactically valid by checking it has balanced braces. Run `grep -c 'joinRequests' firestore.rules` to confirm the new rules section exists.
  </verify>
  <done>useJoinRequestUseCases.ts exists with 7 exported methods. firestore.rules has joinRequests collection rules and teams read-all rule for browsing. No TypeScript errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. `src/interfaces/interfaces.ts` contains `IJoinRequest` interface
3. `src/services/joinRequestFirebase.ts` exports `useJoinRequestFirebase` with all methods
4. `src/composable/useJoinRequestUseCases.ts` exports `useJoinRequestUseCases` with all methods
5. `firestore.rules` contains `joinRequests` collection rules and teams browse rule
6. AuditOperation includes 'joinRequest.approve' and 'joinRequest.decline'
</verification>

<success_criteria>
- IJoinRequest interface with full lifecycle fields (pending/approved/declined/cancelled)
- Firebase service with real-time listeners for teams, user requests, and team requests
- Use case layer with max 5 pending validation and duplicate prevention
- Firestore rules allowing: create own requests, read own requests, power user read/approve/decline, user cancel, browse all teams
- All new code follows existing patterns (error handling, logging, mapFirestoreError)
</success_criteria>

<output>
After completion, create `.planning/phases/12-team-discovery-join-requests/12-01-SUMMARY.md`
</output>
