---
phase: 05-security-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/interfaces/interfaces.ts
  - src/services/auditLogFirebase.ts
  - firestore.rules
autonomous: true

must_haves:
  truths:
    - "Audit log entries can be written to Firestore subcollection teams/{teamId}/auditLogs/{logId}"
    - "Audit log entries can be read by power users from Firestore"
    - "Non-power-user reads of audit logs are denied by security rules"
    - "Audit log write failures do not block the calling operation (non-blocking pattern)"
  artifacts:
    - path: "src/interfaces/interfaces.ts"
      provides: "IAuditLog interface with operation types, actor info, entity info, before/after snapshots"
      contains: "IAuditLog"
    - path: "src/services/auditLogFirebase.ts"
      provides: "writeAuditLog (fire-and-forget) and getAuditLogs (query with filters) functions"
      exports: ["useAuditLogFirebase"]
    - path: "firestore.rules"
      provides: "auditLogs subcollection rules: power users read, authenticated create, app admin full access"
      contains: "auditLogs"
  key_links:
    - from: "src/services/auditLogFirebase.ts"
      to: "src/interfaces/interfaces.ts"
      via: "IAuditLog type import"
      pattern: "import.*IAuditLog.*interfaces"
    - from: "firestore.rules"
      to: "teams/{teamId}/auditLogs/{logId}"
      via: "subcollection security rules"
      pattern: "match /auditLogs/"
---

<objective>
Create the audit log foundation: TypeScript interface, Firebase service with non-blocking write pattern, and Firestore security rules for the auditLogs subcollection.

Purpose: SEC-01 requires a persistent audit trail for sensitive operations. This plan creates the data layer (interface + service + rules) that other plans will integrate into existing services.
Output: IAuditLog interface, useAuditLogFirebase() composable service, updated firestore.rules
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/interfaces/interfaces.ts
@src/services/surveyFirebase.ts
@src/errors/errorMapper.ts
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IAuditLog interface and auditLogFirebase service</name>
  <files>src/interfaces/interfaces.ts, src/services/auditLogFirebase.ts</files>
  <action>
1. Add IAuditLog interface to `src/interfaces/interfaces.ts` at the end, in a new section `// Audit Log`:

```typescript
export type AuditOperation =
  | 'survey.delete'
  | 'fine.create'
  | 'fine.update'
  | 'fine.delete'
  | 'member.remove'
  | 'vote.verify'

export interface IAuditLog {
  id?: string
  teamId: string
  operation: AuditOperation
  actorUid: string
  actorDisplayName: string
  timestamp: Date
  entityId: string
  entityType: 'survey' | 'fine' | 'member' | 'vote'
  before?: Record<string, unknown>
  after?: Record<string, unknown>
  metadata?: Record<string, unknown>
}
```

2. Create `src/services/auditLogFirebase.ts` with `useAuditLogFirebase()` composable:

- Import `addDoc`, `collection`, `doc`, `getDocs`, `query`, `where`, `orderBy`, `limit` from firebase/firestore
- Import `db` from `@/firebase/config`
- Import `IAuditLog` from `@/interfaces/interfaces`
- Import `mapFirestoreError` from `@/errors/errorMapper`
- Import `createLogger` from `src/utils/logger`
- Create scoped logger: `const log = createLogger('auditLogFirebase')`

Functions to implement:

**writeAuditLog(entry: Omit<IAuditLog, 'id'>): void** — Fire-and-forget pattern (NOT async/await at call site). Internally:
- Build collection ref: `collection(doc(db, 'teams', entry.teamId), 'auditLogs')`
- Call `addDoc()` with `{ ...entry, timestamp: new Date() }`
- Chain `.then()` for success logging (log.info with teamId, operation, actorUid, entityId)
- Chain `.catch()` for error logging (log.error) — MUST NOT throw. Audit failures are non-blocking.
- Return the Promise (caller can optionally await but doesn't need to)

**getAuditLogs(teamId: string, filters?: { operation?: AuditOperation; limitCount?: number }): Promise<IAuditLog[]>** — For reading audit logs (used by UI):
- Build collection ref: `collection(doc(db, 'teams', teamId), 'auditLogs')`
- Build query with `orderBy('timestamp', 'desc')`
- If `filters?.operation`, add `where('operation', '==', filters.operation)`
- If `filters?.limitCount`, add `limit(filters.limitCount)`, default to 100
- Execute `getDocs(q)`
- Map results: `snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as IAuditLog))`
- Wrap in try/catch, throw `mapFirestoreError(error, 'read')` on failure

Return both functions from the composable.

IMPORTANT: `writeAuditLog` returns `void` (not Promise<void>) in its signature to signal fire-and-forget intent. The internal implementation returns the Promise chain but callers should NOT await it.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no new errors
- `src/services/auditLogFirebase.ts` exists and exports `useAuditLogFirebase`
- `IAuditLog` interface exists in `src/interfaces/interfaces.ts`
- `writeAuditLog` function does NOT use `await` internally (uses `.then().catch()` chain)
  </verify>
  <done>
- IAuditLog interface defined with all required fields (operation types, actor info, entity info, before/after)
- writeAuditLog uses fire-and-forget pattern (non-blocking)
- getAuditLogs supports filtering by operation type and limit with descending timestamp order
- Both functions use existing error patterns (mapFirestoreError, createLogger)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auditLogs subcollection security rules</name>
  <files>firestore.rules</files>
  <action>
Add auditLogs subcollection rules inside the `match /teams/{teamId}` block in `firestore.rules`, after the existing `cashboxHistory` subcollection rules (around line 141).

Add this rule block:

```
// Subcollection: audit logs - power users read, authenticated create
match /auditLogs/{logId} {
  // Power users can read audit logs for their team
  allow read: if request.auth != null &&
    get(/databases/$(database)/documents/teams/$(teamId)).data.powerusers.hasAny([request.auth.uid]);

  // Authenticated team members can create audit logs (system creates during operations)
  // Validates: teamId matches parent, actorUid matches authenticated user
  allow create: if request.auth != null &&
    request.resource.data.teamId == teamId &&
    request.resource.data.actorUid == request.auth.uid;

  // App admin full access
  allow read, delete: if isAppAdmin();
}
```

Key security decisions:
- READ: Power users only (not regular members) — prevents privacy issues with who-deleted-what visibility
- CREATE: Any authenticated team member whose UID matches actorUid — ensures audit logs are truthful about who performed actions
- No UPDATE: Audit logs are immutable once written
- No DELETE for non-admins: Prevents audit trail tampering
- App admin: Full access for system maintenance
  </action>
  <verify>
- `firestore.rules` contains `match /auditLogs/{logId}` block inside teams match
- Rule allows read only for power users
- Rule allows create only when actorUid matches auth.uid and teamId matches parent
- No update rule exists (immutable logs)
  </verify>
  <done>
- Firestore security rules enforce power-user-only read access for audit logs
- Audit log creation validates actor identity (actorUid == auth.uid) and team ownership (teamId matches parent)
- Audit logs are immutable (no update rule) and tamper-proof (no delete for non-admins)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. IAuditLog interface is importable from `@/interfaces/interfaces`
3. `useAuditLogFirebase()` returns `writeAuditLog` and `getAuditLogs`
4. Security rules file is syntactically valid
5. No existing functionality is broken (all existing tests/builds pass)
</verification>

<success_criteria>
- IAuditLog interface exists with operation, actor, entity, and before/after fields
- auditLogFirebase service implements non-blocking write and filtered read
- Firestore security rules restrict audit log access to power users (read) and authenticated actors (create)
- Zero new TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-security-audit/05-01-SUMMARY.md`
</output>
