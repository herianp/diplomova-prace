---
phase: 05-security-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/teamFirebase.ts
  - src/services/surveyFirebase.ts
  - src/services/cashboxFirebase.ts
  - src/composable/useTeamUseCases.ts
autonomous: true

must_haves:
  truths:
    - "User sees explicit permission denied notification when Firestore rules reject a listener query"
    - "Listener error callbacks no longer silently degrade to empty arrays for permission-denied errors"
    - "Team deletion succeeds with 1000+ documents by using multiple sequential 499-operation batches"
    - "Subcollection documents (fineRules, fines, payments, cashboxHistory, auditLogs) are deleted in batches during team cascade delete"
    - "Auth state is verified before team listeners start (SEC-04 confirmed satisfied by Phase 2)"
  artifacts:
    - path: "src/services/teamFirebase.ts"
      provides: "Enhanced deleteTeam with unlimited batch cascade; getTeamsByUserId with error callback that uses onError handler instead of callback([])"
      contains: "onError"
    - path: "src/services/surveyFirebase.ts"
      provides: "getSurveysByTeamId with error callback that uses onError handler instead of callback([])"
      contains: "onError"
    - path: "src/services/cashboxFirebase.ts"
      provides: "All listener error callbacks use onError handler instead of callback([])"
      contains: "onError"
    - path: "src/composable/useTeamUseCases.ts"
      provides: "setTeamListener handles listener errors with user-visible notifications"
      contains: "permission-denied"
  key_links:
    - from: "src/services/teamFirebase.ts"
      to: "src/composable/useTeamUseCases.ts"
      via: "onError callback parameter"
      pattern: "onError.*permission"
    - from: "src/composable/useTeamUseCases.ts"
      to: "src/services/notificationService.ts"
      via: "notifyError for permission-denied"
      pattern: "notifyError.*permissionDenied"
---

<objective>
Replace silent listener degradation with explicit error surfacing, enhance team cascade delete for unlimited scale, and verify SEC-04 auth coordination.

Purpose: SEC-02 requires permission-denied errors to show user-visible feedback instead of silent empty arrays. SEC-03 requires team deletion to handle 1000+ items. SEC-04 requires verification that auth state is confirmed before listeners.
Output: Updated Firebase services with error surfacing, enhanced cascade delete, SEC-04 verification comment
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/teamFirebase.ts
@src/services/surveyFirebase.ts
@src/services/cashboxFirebase.ts
@src/composable/useTeamUseCases.ts
@src/composable/useAuthUseCases.ts
@src/errors/errorMapper.ts
@src/errors/index.ts
@src/services/notificationService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace silent listener degradation with error surfacing</name>
  <files>src/services/teamFirebase.ts, src/services/surveyFirebase.ts, src/services/cashboxFirebase.ts, src/composable/useTeamUseCases.ts</files>
  <action>
**Pattern change:** All Firestore listener functions (`onSnapshot` error callbacks) currently call `callback([])` on error (silent degradation). Change them to accept an optional `onError` callback parameter. When `permission-denied` error occurs, call `onError` instead of `callback([])`. For other errors, still call `callback([])` for graceful degradation (transient errors may self-resolve).

**1. teamFirebase.ts — `getTeamsByUserId`:**

Change signature to:
```typescript
const getTeamsByUserId = (
  userId: string,
  callback: (teams: ITeam[]) => void,
  onError?: (error: FirestoreError) => void
): Unsubscribe => {
```

In the error callback:
```typescript
}, (error) => {
  const firestoreError = mapFirestoreError(error, 'read')
  log.error('Teams listener failed', { userId, code: error.code, error: firestoreError.message })

  if (error.code === 'permission-denied' && onError) {
    onError(firestoreError)
  } else {
    callback([]) // Graceful degradation for transient errors
  }
})
```

Import `FirestoreError` from `@/errors` and `mapFirestoreError` from `@/errors/errorMapper` (mapFirestoreError already imported, add FirestoreError import).

**2. surveyFirebase.ts — `getSurveysByTeamId`:**

Change signature to:
```typescript
const getSurveysByTeamId = (
  teamId: string,
  callback: (surveys: ISurvey[]) => void,
  onError?: (error: FirestoreError) => void
): Unsubscribe => {
```

Same error callback pattern: call `onError(firestoreError)` for permission-denied, else `callback([])`.

Replace `ListenerError` usage with `mapFirestoreError` for the error callback (use `mapFirestoreError(error, 'read')` instead of `new ListenerError(...)`).

**3. cashboxFirebase.ts — All 5 listeners:**

Update all listener functions to accept optional `onError` parameter:
- `listenToFineRules(teamId, callback, onError?)`
- `listenToFines(teamId, callback, onError?)`
- `listenToPayments(teamId, callback, onError?)`
- `listenToCashboxHistory(teamId, callback, onError?)`

Same pattern in each error callback: `permission-denied` calls `onError`, other errors call `callback([])`.

Import `FirestoreError` from `@/errors` in cashboxFirebase.ts. Replace `ListenerError` with `mapFirestoreError` pattern for error mapping.

**4. useTeamUseCases.ts — `setTeamListener`:**

Pass an `onError` callback to `getTeamsByUserId`:
```typescript
const unsubscribe = teamFirebase.getTeamsByUserId(userId, (teamsList) => {
  teamStore.setTeams(teamsList)

  if (!teamStore.currentTeam && teamsList.length > 0) {
    teamStore.setCurrentTeam(teamsList[0])
  }

  if (isFirstCallback) {
    isFirstCallback = false
    authStore.setTeamReady(true)
    resolve()
  }
}, (error) => {
  // Permission-denied: show user-visible notification (SEC-02)
  log.error('Team listener permission denied', { userId, error: error.message })
  notifyError('errors.firestore.permissionDenied', {
    retry: false
  })
  // Still resolve the promise so app doesn't hang
  if (isFirstCallback) {
    isFirstCallback = false
    authStore.setTeamReady(true)
    resolve()
  }
})
```

Add import for `createLogger` from `src/utils/logger` and create logger instance in the composable.

**5. SEC-04 Verification (code comment only):**

In `useAuthUseCases.ts`, add a documentation comment at line 20 (before `initializeAuth`):
```typescript
/**
 * Initializes auth state using Promise-based coordination (Phase 2).
 * SEC-04: Auth state is confirmed via authStateReady() BEFORE any team
 * listeners start. The authStateListener callback (line 36) only triggers
 * setTeamListener AFTER auth state is fully resolved, eliminating
 * permission-denied flash on cold start.
 *
 * Verified: 2026-02-15 (Phase 5 planning)
 */
```

This is documentation-only — no code changes needed for SEC-04 as Phase 2 already satisfies the requirement.

IMPORTANT: Do NOT change the overall architecture. Only add the optional `onError` parameter and update error callbacks. Existing callers that don't pass `onError` will continue to work exactly as before (graceful degradation).
  </action>
  <verify>
- `npx tsc --noEmit` passes with no new errors
- All listener functions have optional `onError` parameter
- `permission-denied` error in team listener triggers `notifyError` call (not silent `callback([])`)
- Existing callers without `onError` still get `callback([])` behavior (backward compatible)
- SEC-04 verification comment exists in `useAuthUseCases.ts`
  </verify>
  <done>
- All 7 Firestore listeners (1 team, 1 survey, 4 cashbox, 1 cashboxHistory) accept optional onError callback
- Permission-denied errors surface to user via notifyError instead of silent empty array degradation
- Non-permission errors still use graceful degradation (callback([])) for transient failures
- SEC-04 verified as already satisfied by Phase 2 authStateReady() pattern (documented with comment)
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance team cascade delete for unlimited scale</name>
  <files>src/services/teamFirebase.ts</files>
  <action>
Rewrite the `deleteTeam` function in `teamFirebase.ts` to handle unlimited documents using sequential 499-operation batches with progress logging and rate limiting.

**Changes to `deleteTeam`:**

1. Extract a helper function `deleteCollectionInBatches` inside `useTeamFirebase()`:

```typescript
const BATCH_SIZE = 499

const deleteCollectionInBatches = async (
  collectionRef: CollectionReference,
  label: string
): Promise<number> => {
  const snapshot = await getDocs(collectionRef)
  const docs = snapshot.docs

  if (docs.length === 0) return 0

  for (let i = 0; i < docs.length; i += BATCH_SIZE) {
    const batch = writeBatch(db)
    const chunk = docs.slice(i, i + BATCH_SIZE)
    chunk.forEach((d) => batch.delete(d.ref))
    await batch.commit()

    log.info('Batch delete progress', {
      label,
      processed: Math.min(i + BATCH_SIZE, docs.length),
      total: docs.length
    })

    // Rate limiting: 200ms pause every 10 batches (~5000 writes)
    if ((Math.floor(i / BATCH_SIZE) + 1) % 10 === 0) {
      await new Promise(resolve => setTimeout(resolve, 200))
    }
  }

  return docs.length
}
```

Import `CollectionReference` from `firebase/firestore`.

2. Rewrite `deleteTeam` to use the helper:

```typescript
const deleteTeam = async (teamId: string) => {
  try {
    // Delete root-level collections referencing team
    const rootCollections = ['surveys', 'messages', 'notifications', 'teamInvitations']
    for (const col of rootCollections) {
      const q = query(collection(db, col), where('teamId', '==', teamId))
      const snapshot = await getDocs(q)

      // Use batch helper for unlimited scale
      if (snapshot.docs.length > 0) {
        // Convert query result to a pseudo-collection for batch deletion
        for (let i = 0; i < snapshot.docs.length; i += BATCH_SIZE) {
          const batch = writeBatch(db)
          const chunk = snapshot.docs.slice(i, i + BATCH_SIZE)
          chunk.forEach((d) => batch.delete(d.ref))
          await batch.commit()

          log.info('Batch delete progress', {
            teamId,
            collection: col,
            processed: Math.min(i + BATCH_SIZE, snapshot.docs.length),
            total: snapshot.docs.length
          })

          if ((Math.floor(i / BATCH_SIZE) + 1) % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 200))
          }
        }
      }
    }

    // Delete subcollections under team document (includes auditLogs from Phase 5)
    const subcollections = ['fineRules', 'fines', 'payments', 'cashboxTransactions', 'cashboxHistory', 'auditLogs']
    for (const sub of subcollections) {
      const subRef = collection(doc(db, 'teams', teamId), sub)
      await deleteCollectionInBatches(subRef, `${teamId}/${sub}`)
    }

    // Delete votes subcollections for all team surveys (Phase 4 data model)
    const surveysQuery = query(collection(db, 'surveys'), where('teamId', '==', teamId))
    const surveysSnapshot = await getDocs(surveysQuery)

    for (const surveyDoc of surveysSnapshot.docs) {
      const votesRef = collection(doc(db, 'surveys', surveyDoc.id), 'votes')
      await deleteCollectionInBatches(votesRef, `surveys/${surveyDoc.id}/votes`)
    }

    // Finally, delete the team document itself
    await deleteDoc(doc(db, 'teams', teamId))

    log.info('Team cascade delete complete', { teamId })
  } catch (error: unknown) {
    const firestoreError = mapFirestoreError(error, 'delete')
    log.error('Failed to delete team', { teamId, error: firestoreError.message })
    throw firestoreError
  }
}
```

Key enhancements over current code:
- Subcollection deletion now uses 499-chunk batches (current code uses single batch that will fail with >500 docs)
- Added `cashboxHistory` and `auditLogs` to subcollection cleanup list
- Added survey votes subcollection cleanup (Phase 4 data model)
- Progress logging for each batch
- Rate limiting every 10 batches to avoid Firestore quota errors
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `deleteTeam` handles root collections with 499-chunk batches
- `deleteTeam` handles subcollections with 499-chunk batches (not single batch)
- `deleteTeam` cleans up survey votes subcollections
- `auditLogs` included in subcollection cleanup list
- Progress logging on each batch commit
  </verify>
  <done>
- Team deletion handles 1000+ documents per collection without transaction size errors
- All subcollections (including cashboxHistory, auditLogs, survey votes) cleaned up in batches
- Rate limiting prevents Firestore quota exhaustion during large deletions
- Progress logging provides visibility into cascade delete status
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. All 7 listeners accept optional onError parameter
3. Permission-denied errors show user notification (not silent empty array)
4. deleteTeam uses 499-chunk batches for both root collections and subcollections
5. SEC-04 verification comment exists in useAuthUseCases.ts
6. Backward compatible: existing callers without onError work unchanged
</verification>

<success_criteria>
- Permission-denied listener errors surface to user via notifyError (SEC-02)
- Team cascade delete handles unlimited documents with 499-operation batches (SEC-03)
- Auth state verified before listeners via documentation review (SEC-04)
- Zero new TypeScript compilation errors
- Backward compatible with existing listener callers
</success_criteria>

<output>
After completion, create `.planning/phases/05-security-audit/05-02-SUMMARY.md`
</output>
