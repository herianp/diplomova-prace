---
phase: 05-security-audit
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/services/surveyFirebase.ts
  - src/services/cashboxFirebase.ts
  - src/services/teamFirebase.ts
  - src/composable/useSurveyUseCases.ts
  - src/composable/useCashboxUseCases.ts
autonomous: true

must_haves:
  truths:
    - "Survey deletion writes audit log entry with survey title, actor info, and timestamp"
    - "Fine creation and deletion writes audit log entry"
    - "Team member removal writes audit log entry with removed member's UID"
    - "Survey verification writes audit log entry with verifier info"
    - "All audit writes are non-blocking (do not delay user-facing operations)"
  artifacts:
    - path: "src/services/surveyFirebase.ts"
      provides: "deleteSurvey and verifySurvey with audit log integration"
      contains: "writeAuditLog"
    - path: "src/services/cashboxFirebase.ts"
      provides: "addFine and deleteFine with audit log integration"
      contains: "writeAuditLog"
    - path: "src/services/teamFirebase.ts"
      provides: "removeMember with audit log integration"
      contains: "writeAuditLog"
  key_links:
    - from: "src/services/surveyFirebase.ts"
      to: "src/services/auditLogFirebase.ts"
      via: "writeAuditLog import and fire-and-forget call"
      pattern: "writeAuditLog"
    - from: "src/services/cashboxFirebase.ts"
      to: "src/services/auditLogFirebase.ts"
      via: "writeAuditLog import and fire-and-forget call"
      pattern: "writeAuditLog"
    - from: "src/services/teamFirebase.ts"
      to: "src/services/auditLogFirebase.ts"
      via: "writeAuditLog import and fire-and-forget call"
      pattern: "writeAuditLog"
---

<objective>
Integrate audit logging into existing sensitive operations: survey deletion, survey verification, fine creation/deletion, and team member removal.

Purpose: SEC-01 requires audit trail for all sensitive operations. This plan wires the audit log service (from Plan 01) into existing Firebase services using the non-blocking fire-and-forget pattern.
Output: Existing services emit audit log entries after successful operations
</objective>

<execution_context>
@C:/Users/Developer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-security-audit/05-01-SUMMARY.md
@src/services/surveyFirebase.ts
@src/services/cashboxFirebase.ts
@src/services/teamFirebase.ts
@src/services/auditLogFirebase.ts
@src/composable/useSurveyUseCases.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit logging to survey and team operations</name>
  <files>src/services/surveyFirebase.ts, src/services/teamFirebase.ts</files>
  <action>
**Pattern for all audit integrations:** After the main Firestore operation succeeds (inside the try block, after the await), call `writeAuditLog()` WITHOUT awaiting it. The function signatures need to be updated to accept actor information (actorUid, actorDisplayName) where they don't already have it.

**1. surveyFirebase.ts — `deleteSurvey`:**

Update signature to accept audit context:
```typescript
const deleteSurvey = async (
  surveyId: string,
  auditContext?: { teamId: string; actorUid: string; actorDisplayName: string; surveyTitle?: string }
) => {
```

After the successful `deleteDoc`, add non-blocking audit write:
```typescript
await deleteDoc(doc(db, 'surveys', surveyId))

// Audit log (non-blocking, SEC-01)
if (auditContext) {
  const { writeAuditLog } = useAuditLogFirebase()
  writeAuditLog({
    teamId: auditContext.teamId,
    operation: 'survey.delete',
    actorUid: auditContext.actorUid,
    actorDisplayName: auditContext.actorDisplayName,
    timestamp: new Date(),
    entityId: surveyId,
    entityType: 'survey',
    before: auditContext.surveyTitle ? { title: auditContext.surveyTitle } : undefined
  })
}
```

Import `useAuditLogFirebase` from `@/services/auditLogFirebase`.

**2. surveyFirebase.ts — `verifySurvey`:**

Update signature to accept audit context:
```typescript
const verifySurvey = async (
  surveyId: string,
  verifiedBy: string,
  updatedVotes?: IVote[],
  auditContext?: { teamId: string; actorDisplayName: string }
) => {
```

After the successful update (at end of try block), add:
```typescript
// Audit log (non-blocking, SEC-01)
if (auditContext) {
  const { writeAuditLog } = useAuditLogFirebase()
  writeAuditLog({
    teamId: auditContext.teamId,
    operation: 'vote.verify',
    actorUid: verifiedBy,
    actorDisplayName: auditContext.actorDisplayName,
    timestamp: new Date(),
    entityId: surveyId,
    entityType: 'vote',
    metadata: updatedVotes ? { voteCount: updatedVotes.length } : undefined
  })
}
```

**3. teamFirebase.ts — `removeMember`:**

Update signature to accept audit context:
```typescript
const removeMember = async (
  teamId: string,
  memberUid: string,
  auditContext?: { actorUid: string; actorDisplayName: string; memberDisplayName?: string }
): Promise<void> => {
```

After the successful `updateDoc`, add:
```typescript
// Audit log (non-blocking, SEC-01)
if (auditContext) {
  const { writeAuditLog } = useAuditLogFirebase()
  writeAuditLog({
    teamId,
    operation: 'member.remove',
    actorUid: auditContext.actorUid,
    actorDisplayName: auditContext.actorDisplayName,
    timestamp: new Date(),
    entityId: memberUid,
    entityType: 'member',
    metadata: auditContext.memberDisplayName ? { memberDisplayName: auditContext.memberDisplayName } : undefined
  })
}
```

Import `useAuditLogFirebase` from `@/services/auditLogFirebase` in teamFirebase.ts.

CRITICAL: All `writeAuditLog()` calls must NOT be awaited. They are fire-and-forget. The audit context parameter is optional so existing callers without audit context continue to work unchanged.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `deleteSurvey` accepts optional `auditContext` parameter
- `verifySurvey` accepts optional `auditContext` parameter
- `removeMember` accepts optional `auditContext` parameter
- All `writeAuditLog` calls are NOT preceded by `await`
- Existing callers without auditContext still work (parameter is optional)
  </verify>
  <done>
- Survey deletion emits audit log with survey title and actor info
- Survey verification emits audit log with verifier and vote count
- Member removal emits audit log with removed member UID
- All audit writes are non-blocking (fire-and-forget pattern)
- Backward compatible with existing callers
  </done>
</task>

<task type="auto">
  <name>Task 2: Add audit logging to cashbox operations and update use case callers</name>
  <files>src/services/cashboxFirebase.ts, src/composable/useSurveyUseCases.ts, src/composable/useCashboxUseCases.ts</files>
  <action>
**1. cashboxFirebase.ts — `addFine`:**

Update signature:
```typescript
const addFine = async (
  teamId: string,
  fine: Omit<IFine, 'id'>,
  auditContext?: { actorUid: string; actorDisplayName: string }
): Promise<void> => {
```

After successful `addDoc`:
```typescript
// Audit log (non-blocking, SEC-01)
if (auditContext) {
  const { writeAuditLog } = useAuditLogFirebase()
  writeAuditLog({
    teamId,
    operation: 'fine.create',
    actorUid: auditContext.actorUid,
    actorDisplayName: auditContext.actorDisplayName,
    timestamp: new Date(),
    entityId: fine.playerId,
    entityType: 'fine',
    after: { amount: fine.amount, reason: fine.reason, source: fine.source }
  })
}
```

**2. cashboxFirebase.ts — `deleteFine`:**

Update signature:
```typescript
const deleteFine = async (
  teamId: string,
  fineId: string,
  auditContext?: { actorUid: string; actorDisplayName: string; fineAmount?: number; fineReason?: string }
): Promise<void> => {
```

After successful `deleteDoc`:
```typescript
// Audit log (non-blocking, SEC-01)
if (auditContext) {
  const { writeAuditLog } = useAuditLogFirebase()
  writeAuditLog({
    teamId,
    operation: 'fine.delete',
    actorUid: auditContext.actorUid,
    actorDisplayName: auditContext.actorDisplayName,
    timestamp: new Date(),
    entityId: fineId,
    entityType: 'fine',
    before: auditContext.fineAmount ? { amount: auditContext.fineAmount, reason: auditContext.fineReason } : undefined
  })
}
```

Import `useAuditLogFirebase` from `@/services/auditLogFirebase` in cashboxFirebase.ts.

**3. Update use case callers to pass audit context:**

Find all callers of `deleteSurvey`, `verifySurvey`, `removeMember`, `addFine`, `deleteFine` in the composables and update them to pass audit context.

In `useSurveyUseCases.ts` (or wherever `deleteSurvey` is called from the composable layer):
- Look for the existing call to `surveyFirebase.deleteSurvey(surveyId)`
- Update to pass audit context: `surveyFirebase.deleteSurvey(surveyId, { teamId, actorUid: authStore.user!.uid, actorDisplayName: authStore.user!.displayName || authStore.user!.email || 'Unknown', surveyTitle: survey?.title })`
- The caller already has access to `authStore` (imported or available via useAuthStore())

In `useCashboxUseCases.ts` (or wherever fine operations are called):
- Find calls to `addFine` and `deleteFine`
- Pass audit context with `actorUid: authStore.user!.uid, actorDisplayName: authStore.user!.displayName || authStore.user!.email || 'Unknown'`

NOTE: If the composable doesn't currently import authStore, add the import. The pattern `useAuthStore()` is already used in other composables (see useTeamUseCases.ts).

If you cannot find explicit use case composables for some operations (e.g., if pages call Firebase services directly), add audit context at the page/component level where the call originates. Search for all callers using grep for the function names.

IMPORTANT: Do not modify `bulkAddFines` for audit logging — bulk auto-generated fines from survey verification are not considered "sensitive operations" that need individual audit entries. The survey verification audit entry covers the triggering action.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `addFine` accepts optional `auditContext` parameter
- `deleteFine` accepts optional `auditContext` parameter
- Use case callers pass audit context with actorUid and actorDisplayName from authStore
- No `await` before any `writeAuditLog` call
- Existing callers without auditContext still work (backward compatible)
  </verify>
  <done>
- Fine creation emits audit log with amount, reason, and actor info
- Fine deletion emits audit log with fine details and actor info
- All use case layer callers provide audit context from auth store
- All audit writes remain non-blocking
- Backward compatible with any callers that don't provide audit context
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. All 5 sensitive operations (survey delete, survey verify, fine create, fine delete, member remove) call writeAuditLog
3. All writeAuditLog calls are fire-and-forget (no await)
4. Audit context is optional in all function signatures (backward compatible)
5. Use case callers provide actorUid and actorDisplayName from authStore
</verification>

<success_criteria>
- Power user actions (survey deletion, verification, fine management, member removal) generate audit log entries
- Audit log entries include actor identity, timestamp, entity details, and before/after state where applicable
- No user-facing operation is delayed by audit log writes
- Zero new TypeScript compilation errors
- All function signature changes are backward compatible
</success_criteria>

<output>
After completion, create `.planning/phases/05-security-audit/05-03-SUMMARY.md`
</output>
